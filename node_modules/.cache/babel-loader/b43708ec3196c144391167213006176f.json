{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _SimpleSchema = require(\"./SimpleSchema\");\n\nvar _utility = require(\"./utility\");\n\nvar _typeValidator = _interopRequireDefault(require(\"./validation/typeValidator\"));\n\nvar _requiredValidator = _interopRequireDefault(require(\"./validation/requiredValidator\"));\n\nvar _allowedValuesValidator = _interopRequireDefault(require(\"./validation/allowedValuesValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction shouldCheck(key) {\n  if (key === '$pushAll') throw new Error('$pushAll is not supported; use $push + $each');\n  return ['$pull', '$pullAll', '$pop', '$slice'].indexOf(key) === -1;\n}\n\nfunction doValidation(_ref) {\n  var extendedCustomContext = _ref.extendedCustomContext,\n      ignoreTypes = _ref.ignoreTypes,\n      isModifier = _ref.isModifier,\n      isUpsert = _ref.isUpsert,\n      keysToValidate = _ref.keysToValidate,\n      mongoObject = _ref.mongoObject,\n      obj = _ref.obj,\n      schema = _ref.schema,\n      validationContext = _ref.validationContext; // First do some basic checks of the object, and throw errors if necessary\n\n  if (!obj || _typeof(obj) !== 'object' && typeof obj !== 'function') {\n    throw new Error('The first argument of validate() must be an object');\n  }\n\n  if (!isModifier && (0, _utility.looksLikeModifier)(obj)) {\n    throw new Error('When the validation object contains mongo operators, you must set the modifier option to true');\n  }\n\n  function getFieldInfo(key) {\n    // Create mongoObject if necessary, cache for speed\n    if (!mongoObject) mongoObject = new _mongoObject.default(obj, schema.blackboxKeys());\n    var keyInfo = mongoObject.getInfoForKey(key) || {};\n    return {\n      isSet: keyInfo.value !== undefined,\n      value: keyInfo.value,\n      operator: keyInfo.operator || null\n    };\n  }\n\n  var validationErrors = []; // Validation function called for each affected key\n\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, isInArrayItemObject, isInSubObject) {\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      // We don't need KEY_NOT_IN_SCHEMA error for $unset and we also don't need to continue\n      if (op === '$unset') return;\n      validationErrors.push({\n        name: affectedKey,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: val\n      });\n      return;\n    } // For $rename, make sure that the new name is allowed by the schema\n\n\n    if (op === '$rename' && !schema.allowsKey(val)) {\n      validationErrors.push({\n        name: val,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: null\n      });\n      return;\n    } // Prepare the context object for the validator functions\n\n\n    var fieldParentNameWithEndDot = (0, _utility.getParentOfKey)(affectedKey, true);\n    var fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n    var fieldValidationErrors = [];\n\n    var validatorContext = _objectSpread({\n      addValidationErrors: function addValidationErrors(errors) {\n        errors.forEach(function (error) {\n          return fieldValidationErrors.push(error);\n        });\n      },\n      field: function field(fName) {\n        return getFieldInfo(fName);\n      },\n      genericKey: affectedKeyGeneric,\n      isInArrayItemObject: isInArrayItemObject,\n      isInSubObject: isInSubObject,\n      isModifier: isModifier,\n      isSet: val !== undefined,\n      key: affectedKey,\n      obj: obj,\n      operator: op,\n      parentField: function parentField() {\n        return getFieldInfo(fieldParentName);\n      },\n      siblingField: function siblingField(fName) {\n        return getFieldInfo(fieldParentNameWithEndDot + fName);\n      },\n      validationContext: validationContext,\n      value: val,\n      // Value checks are not necessary for null or undefined values, except\n      // for non-optional null array items, or for $unset or $rename values\n      valueShouldBeChecked: op !== '$unset' && op !== '$rename' && (val !== undefined && val !== null || affectedKeyGeneric.slice(-2) === '.$' && val === null && !def.optional)\n    }, extendedCustomContext || {});\n\n    var builtInValidators = [_requiredValidator.default, _typeValidator.default, _allowedValuesValidator.default];\n    var validators = builtInValidators.concat(schema._validators).concat(_SimpleSchema.SimpleSchema._validators); // Loop through each of the definitions in the SimpleSchemaGroup.\n    // If any return true, we're valid.\n\n    var fieldIsValid = def.type.some(function (typeDef) {\n      // If the type is SimpleSchema.Any, then it is valid:\n      if (typeDef === _SimpleSchema.SimpleSchema.Any) return true;\n\n      var type = def.type,\n          definitionWithoutType = _objectWithoutProperties(def, [\"type\"]); // eslint-disable-line no-unused-vars\n\n\n      var finalValidatorContext = _objectSpread({}, validatorContext, {\n        // Take outer definition props like \"optional\" and \"label\"\n        // and add them to inner props like \"type\" and \"min\"\n        definition: _objectSpread({}, definitionWithoutType, {}, typeDef)\n      }); // Add custom field validators to the list after the built-in\n      // validators but before the schema and global validators.\n\n\n      var fieldValidators = validators.slice(0);\n\n      if (typeof typeDef.custom === 'function') {\n        fieldValidators.splice(builtInValidators.length, 0, typeDef.custom);\n      } // We use _.every just so that we don't continue running more validator\n      // functions after the first one returns false or an error string.\n\n\n      return fieldValidators.every(function (validator) {\n        var result = validator.call(finalValidatorContext); // If the validator returns a string, assume it is the\n        // error type.\n\n        if (typeof result === 'string') {\n          fieldValidationErrors.push({\n            name: affectedKey,\n            type: result,\n            value: val\n          });\n          return false;\n        } // If the validator returns an object, assume it is an\n        // error object.\n\n\n        if (_typeof(result) === 'object' && result !== null) {\n          fieldValidationErrors.push(_objectSpread({\n            name: affectedKey,\n            value: val\n          }, result));\n          return false;\n        } // If the validator returns false, assume they already\n        // called this.addValidationErrors within the function\n\n\n        if (result === false) return false; // Any other return value we assume means it was valid\n\n        return true;\n      });\n    });\n\n    if (!fieldIsValid) {\n      validationErrors = validationErrors.concat(fieldValidationErrors);\n    }\n  } // The recursive function\n\n\n  function checkObj(_ref2) {\n    var val = _ref2.val,\n        affectedKey = _ref2.affectedKey,\n        operator = _ref2.operator,\n        _ref2$isInArrayItemOb = _ref2.isInArrayItemObject,\n        isInArrayItemObject = _ref2$isInArrayItemOb === void 0 ? false : _ref2$isInArrayItemOb,\n        _ref2$isInSubObject = _ref2.isInSubObject,\n        isInSubObject = _ref2$isInSubObject === void 0 ? false : _ref2$isInSubObject;\n    var affectedKeyGeneric;\n    var def;\n\n    if (affectedKey) {\n      // When we hit a blackbox key, we don't progress any further\n      if (schema.keyIsInBlackBox(affectedKey)) return; // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n\n      affectedKeyGeneric = _mongoObject.default.makeKeyGeneric(affectedKey);\n      var shouldValidateKey = !keysToValidate || keysToValidate.some(function (keyToValidate) {\n        return keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric || affectedKey.startsWith(\"\".concat(keyToValidate, \".\")) || affectedKeyGeneric.startsWith(\"\".concat(keyToValidate, \".\"));\n      }); // Prepare the context object for the rule functions\n\n      var fieldParentNameWithEndDot = (0, _utility.getParentOfKey)(affectedKey, true);\n      var fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n\n      var functionsContext = _objectSpread({\n        field: function field(fName) {\n          return getFieldInfo(fName);\n        },\n        genericKey: affectedKeyGeneric,\n        isInArrayItemObject: isInArrayItemObject,\n        isInSubObject: isInSubObject,\n        isModifier: isModifier,\n        isSet: val !== undefined,\n        key: affectedKey,\n        obj: obj,\n        operator: operator,\n        parentField: function parentField() {\n          return getFieldInfo(fieldParentName);\n        },\n        siblingField: function siblingField(fName) {\n          return getFieldInfo(fieldParentNameWithEndDot + fName);\n        },\n        value: val\n      }, extendedCustomContext || {}); // Perform validation for this key\n\n\n      def = schema.getDefinition(affectedKey, null, functionsContext);\n\n      if (shouldValidateKey) {\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, isInArrayItemObject, isInSubObject);\n      }\n    } // If affectedKeyGeneric is undefined due to this being the first run of this\n    // function, objectKeys will return the top-level keys.\n\n\n    var childKeys = schema.objectKeys(affectedKeyGeneric); // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n\n    if ((val === undefined || val === null) && (!def || !def.optional && childKeys && childKeys.length > 0)) {\n      val = {};\n    } // Loop through arrays\n\n\n    if (Array.isArray(val)) {\n      val.forEach(function (v, i) {\n        checkObj({\n          val: v,\n          affectedKey: \"\".concat(affectedKey, \".\").concat(i),\n          operator: operator\n        });\n      });\n    } else if ((0, _utility.isObjectWeShouldTraverse)(val) && (!def || !schema._blackboxKeys.has(affectedKey))) {\n      // Loop through object keys\n      // Get list of present keys\n      var presentKeys = Object.keys(val); // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n\n      isInArrayItemObject = affectedKeyGeneric && affectedKeyGeneric.slice(-2) === '.$';\n      var checkedKeys = []; // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n\n      /* eslint-disable no-restricted-syntax */\n\n      for (var _i = 0, _arr = [].concat(_toConsumableArray(presentKeys), _toConsumableArray(childKeys)); _i < _arr.length; _i++) {\n        var key = _arr[_i]; // `childKeys` and `presentKeys` may contain the same keys, so make\n        // sure we run only once per unique key\n\n        if (checkedKeys.indexOf(key) !== -1) continue;\n        checkedKeys.push(key);\n        checkObj({\n          val: val[key],\n          affectedKey: (0, _utility.appendAffectedKey)(affectedKey, key),\n          operator: operator,\n          isInArrayItemObject: isInArrayItemObject,\n          isInSubObject: true\n        });\n      }\n      /* eslint-enable no-restricted-syntax */\n\n    }\n  }\n\n  function checkModifier(mod) {\n    // Loop through operators\n    Object.keys(mod).forEach(function (op) {\n      var opObj = mod[op]; // If non-operators are mixed in, throw error\n\n      if (op.slice(0, 1) !== '$') {\n        throw new Error(\"Expected '\".concat(op, \"' to be a modifier operator like '$set'\"));\n      }\n\n      if (shouldCheck(op)) {\n        // For an upsert, missing props would not be set if an insert is performed,\n        // so we check them all with undefined value to force any 'required' checks to fail\n        if (isUpsert && (op === '$set' || op === '$setOnInsert')) {\n          var presentKeys = Object.keys(opObj);\n          schema.objectKeys().forEach(function (schemaKey) {\n            if (!presentKeys.includes(schemaKey)) {\n              checkObj({\n                val: undefined,\n                affectedKey: schemaKey,\n                operator: op\n              });\n            }\n          });\n        } // Don't use forEach here because it will not properly handle an\n        // object that has a property named `length`\n\n\n        Object.keys(opObj).forEach(function (k) {\n          var v = opObj[k];\n\n          if (op === '$push' || op === '$addToSet') {\n            if (_typeof(v) === 'object' && '$each' in v) {\n              v = v.$each;\n            } else {\n              k = \"\".concat(k, \".0\");\n            }\n          }\n\n          checkObj({\n            val: v,\n            affectedKey: k,\n            operator: op\n          });\n        });\n      }\n    });\n  } // Kick off the validation\n\n\n  if (isModifier) {\n    checkModifier(obj);\n  } else {\n    checkObj({\n      val: obj\n    });\n  } // Custom whole-doc validators\n\n\n  var docValidators = schema._docValidators.concat(_SimpleSchema.SimpleSchema._docValidators);\n\n  var docValidatorContext = _objectSpread({\n    ignoreTypes: ignoreTypes,\n    isModifier: isModifier,\n    isUpsert: isUpsert,\n    keysToValidate: keysToValidate,\n    mongoObject: mongoObject,\n    obj: obj,\n    schema: schema,\n    validationContext: validationContext\n  }, extendedCustomContext || {});\n\n  docValidators.forEach(function (func) {\n    var errors = func.call(docValidatorContext, obj);\n    if (!Array.isArray(errors)) throw new Error('Custom doc validator must return an array of error objects');\n    if (errors.length) validationErrors = validationErrors.concat(errors);\n  });\n  var addedFieldNames = [];\n  validationErrors = validationErrors.filter(function (errObj) {\n    // Remove error types the user doesn't care about\n    if (ignoreTypes.includes(errObj.type)) return false; // Make sure there is only one error per fieldName\n\n    if (addedFieldNames.includes(errObj.name)) return false;\n    addedFieldNames.push(errObj.name);\n    return true;\n  });\n  return validationErrors;\n}\n\nvar _default = doValidation;\nexports.default = _default;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","map":{"version":3,"sources":["/Users/rjgleave/mysrc/oneq-work/sa-form/node_modules/simpl-schema/dist/doValidation.js"],"names":["Object","defineProperty","exports","value","default","_mongoObject","_interopRequireDefault","require","_SimpleSchema","_utility","_typeValidator","_requiredValidator","_allowedValuesValidator","obj","__esModule","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","getOwnPropertySymbols","sourceSymbolKeys","indexOf","propertyIsEnumerable","sourceKeys","keys","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","_typeof","constructor","shouldCheck","Error","doValidation","_ref","extendedCustomContext","ignoreTypes","isModifier","isUpsert","keysToValidate","mongoObject","schema","validationContext","looksLikeModifier","getFieldInfo","blackboxKeys","keyInfo","getInfoForKey","isSet","undefined","operator","validationErrors","validate","val","affectedKey","affectedKeyGeneric","def","op","isInArrayItemObject","isInSubObject","name","type","SimpleSchema","ErrorTypes","KEY_NOT_IN_SCHEMA","allowsKey","fieldParentNameWithEndDot","getParentOfKey","fieldParentName","slice","fieldValidationErrors","validatorContext","addValidationErrors","errors","error","field","fName","genericKey","parentField","siblingField","valueShouldBeChecked","optional","builtInValidators","validators","concat","_validators","fieldIsValid","some","typeDef","Any","definitionWithoutType","finalValidatorContext","definition","fieldValidators","custom","splice","every","validator","result","checkObj","_ref2","_ref2$isInArrayItemOb","_ref2$isInSubObject","keyIsInBlackBox","makeKeyGeneric","shouldValidateKey","keyToValidate","startsWith","functionsContext","getDefinition","childKeys","objectKeys","v","isObjectWeShouldTraverse","_blackboxKeys","has","presentKeys","checkedKeys","_i","_arr","appendAffectedKey","checkModifier","mod","opObj","schemaKey","includes","k","$each","docValidators","_docValidators","docValidatorContext","func","addedFieldNames","errObj","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _SimpleSchema = require(\"./SimpleSchema\");\n\nvar _utility = require(\"./utility\");\n\nvar _typeValidator = _interopRequireDefault(require(\"./validation/typeValidator\"));\n\nvar _requiredValidator = _interopRequireDefault(require(\"./validation/requiredValidator\"));\n\nvar _allowedValuesValidator = _interopRequireDefault(require(\"./validation/allowedValuesValidator\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction shouldCheck(key) {\n  if (key === '$pushAll') throw new Error('$pushAll is not supported; use $push + $each');\n  return ['$pull', '$pullAll', '$pop', '$slice'].indexOf(key) === -1;\n}\n\nfunction doValidation(_ref) {\n  var extendedCustomContext = _ref.extendedCustomContext,\n      ignoreTypes = _ref.ignoreTypes,\n      isModifier = _ref.isModifier,\n      isUpsert = _ref.isUpsert,\n      keysToValidate = _ref.keysToValidate,\n      mongoObject = _ref.mongoObject,\n      obj = _ref.obj,\n      schema = _ref.schema,\n      validationContext = _ref.validationContext;\n\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!obj || _typeof(obj) !== 'object' && typeof obj !== 'function') {\n    throw new Error('The first argument of validate() must be an object');\n  }\n\n  if (!isModifier && (0, _utility.looksLikeModifier)(obj)) {\n    throw new Error('When the validation object contains mongo operators, you must set the modifier option to true');\n  }\n\n  function getFieldInfo(key) {\n    // Create mongoObject if necessary, cache for speed\n    if (!mongoObject) mongoObject = new _mongoObject.default(obj, schema.blackboxKeys());\n    var keyInfo = mongoObject.getInfoForKey(key) || {};\n    return {\n      isSet: keyInfo.value !== undefined,\n      value: keyInfo.value,\n      operator: keyInfo.operator || null\n    };\n  }\n\n  var validationErrors = []; // Validation function called for each affected key\n\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, isInArrayItemObject, isInSubObject) {\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      // We don't need KEY_NOT_IN_SCHEMA error for $unset and we also don't need to continue\n      if (op === '$unset') return;\n      validationErrors.push({\n        name: affectedKey,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: val\n      });\n      return;\n    } // For $rename, make sure that the new name is allowed by the schema\n\n\n    if (op === '$rename' && !schema.allowsKey(val)) {\n      validationErrors.push({\n        name: val,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: null\n      });\n      return;\n    } // Prepare the context object for the validator functions\n\n\n    var fieldParentNameWithEndDot = (0, _utility.getParentOfKey)(affectedKey, true);\n    var fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n    var fieldValidationErrors = [];\n\n    var validatorContext = _objectSpread({\n      addValidationErrors: function addValidationErrors(errors) {\n        errors.forEach(function (error) {\n          return fieldValidationErrors.push(error);\n        });\n      },\n      field: function field(fName) {\n        return getFieldInfo(fName);\n      },\n      genericKey: affectedKeyGeneric,\n      isInArrayItemObject: isInArrayItemObject,\n      isInSubObject: isInSubObject,\n      isModifier: isModifier,\n      isSet: val !== undefined,\n      key: affectedKey,\n      obj: obj,\n      operator: op,\n      parentField: function parentField() {\n        return getFieldInfo(fieldParentName);\n      },\n      siblingField: function siblingField(fName) {\n        return getFieldInfo(fieldParentNameWithEndDot + fName);\n      },\n      validationContext: validationContext,\n      value: val,\n      // Value checks are not necessary for null or undefined values, except\n      // for non-optional null array items, or for $unset or $rename values\n      valueShouldBeChecked: op !== '$unset' && op !== '$rename' && (val !== undefined && val !== null || affectedKeyGeneric.slice(-2) === '.$' && val === null && !def.optional)\n    }, extendedCustomContext || {});\n\n    var builtInValidators = [_requiredValidator.default, _typeValidator.default, _allowedValuesValidator.default];\n    var validators = builtInValidators.concat(schema._validators).concat(_SimpleSchema.SimpleSchema._validators); // Loop through each of the definitions in the SimpleSchemaGroup.\n    // If any return true, we're valid.\n\n    var fieldIsValid = def.type.some(function (typeDef) {\n      // If the type is SimpleSchema.Any, then it is valid:\n      if (typeDef === _SimpleSchema.SimpleSchema.Any) return true;\n\n      var type = def.type,\n          definitionWithoutType = _objectWithoutProperties(def, [\"type\"]); // eslint-disable-line no-unused-vars\n\n\n      var finalValidatorContext = _objectSpread({}, validatorContext, {\n        // Take outer definition props like \"optional\" and \"label\"\n        // and add them to inner props like \"type\" and \"min\"\n        definition: _objectSpread({}, definitionWithoutType, {}, typeDef)\n      }); // Add custom field validators to the list after the built-in\n      // validators but before the schema and global validators.\n\n\n      var fieldValidators = validators.slice(0);\n\n      if (typeof typeDef.custom === 'function') {\n        fieldValidators.splice(builtInValidators.length, 0, typeDef.custom);\n      } // We use _.every just so that we don't continue running more validator\n      // functions after the first one returns false or an error string.\n\n\n      return fieldValidators.every(function (validator) {\n        var result = validator.call(finalValidatorContext); // If the validator returns a string, assume it is the\n        // error type.\n\n        if (typeof result === 'string') {\n          fieldValidationErrors.push({\n            name: affectedKey,\n            type: result,\n            value: val\n          });\n          return false;\n        } // If the validator returns an object, assume it is an\n        // error object.\n\n\n        if (_typeof(result) === 'object' && result !== null) {\n          fieldValidationErrors.push(_objectSpread({\n            name: affectedKey,\n            value: val\n          }, result));\n          return false;\n        } // If the validator returns false, assume they already\n        // called this.addValidationErrors within the function\n\n\n        if (result === false) return false; // Any other return value we assume means it was valid\n\n        return true;\n      });\n    });\n\n    if (!fieldIsValid) {\n      validationErrors = validationErrors.concat(fieldValidationErrors);\n    }\n  } // The recursive function\n\n\n  function checkObj(_ref2) {\n    var val = _ref2.val,\n        affectedKey = _ref2.affectedKey,\n        operator = _ref2.operator,\n        _ref2$isInArrayItemOb = _ref2.isInArrayItemObject,\n        isInArrayItemObject = _ref2$isInArrayItemOb === void 0 ? false : _ref2$isInArrayItemOb,\n        _ref2$isInSubObject = _ref2.isInSubObject,\n        isInSubObject = _ref2$isInSubObject === void 0 ? false : _ref2$isInSubObject;\n    var affectedKeyGeneric;\n    var def;\n\n    if (affectedKey) {\n      // When we hit a blackbox key, we don't progress any further\n      if (schema.keyIsInBlackBox(affectedKey)) return; // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n\n      affectedKeyGeneric = _mongoObject.default.makeKeyGeneric(affectedKey);\n      var shouldValidateKey = !keysToValidate || keysToValidate.some(function (keyToValidate) {\n        return keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric || affectedKey.startsWith(\"\".concat(keyToValidate, \".\")) || affectedKeyGeneric.startsWith(\"\".concat(keyToValidate, \".\"));\n      }); // Prepare the context object for the rule functions\n\n      var fieldParentNameWithEndDot = (0, _utility.getParentOfKey)(affectedKey, true);\n      var fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n\n      var functionsContext = _objectSpread({\n        field: function field(fName) {\n          return getFieldInfo(fName);\n        },\n        genericKey: affectedKeyGeneric,\n        isInArrayItemObject: isInArrayItemObject,\n        isInSubObject: isInSubObject,\n        isModifier: isModifier,\n        isSet: val !== undefined,\n        key: affectedKey,\n        obj: obj,\n        operator: operator,\n        parentField: function parentField() {\n          return getFieldInfo(fieldParentName);\n        },\n        siblingField: function siblingField(fName) {\n          return getFieldInfo(fieldParentNameWithEndDot + fName);\n        },\n        value: val\n      }, extendedCustomContext || {}); // Perform validation for this key\n\n\n      def = schema.getDefinition(affectedKey, null, functionsContext);\n\n      if (shouldValidateKey) {\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, isInArrayItemObject, isInSubObject);\n      }\n    } // If affectedKeyGeneric is undefined due to this being the first run of this\n    // function, objectKeys will return the top-level keys.\n\n\n    var childKeys = schema.objectKeys(affectedKeyGeneric); // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n\n    if ((val === undefined || val === null) && (!def || !def.optional && childKeys && childKeys.length > 0)) {\n      val = {};\n    } // Loop through arrays\n\n\n    if (Array.isArray(val)) {\n      val.forEach(function (v, i) {\n        checkObj({\n          val: v,\n          affectedKey: \"\".concat(affectedKey, \".\").concat(i),\n          operator: operator\n        });\n      });\n    } else if ((0, _utility.isObjectWeShouldTraverse)(val) && (!def || !schema._blackboxKeys.has(affectedKey))) {\n      // Loop through object keys\n      // Get list of present keys\n      var presentKeys = Object.keys(val); // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n\n      isInArrayItemObject = affectedKeyGeneric && affectedKeyGeneric.slice(-2) === '.$';\n      var checkedKeys = []; // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n\n      /* eslint-disable no-restricted-syntax */\n\n      for (var _i = 0, _arr = [].concat(_toConsumableArray(presentKeys), _toConsumableArray(childKeys)); _i < _arr.length; _i++) {\n        var key = _arr[_i];\n        // `childKeys` and `presentKeys` may contain the same keys, so make\n        // sure we run only once per unique key\n        if (checkedKeys.indexOf(key) !== -1) continue;\n        checkedKeys.push(key);\n        checkObj({\n          val: val[key],\n          affectedKey: (0, _utility.appendAffectedKey)(affectedKey, key),\n          operator: operator,\n          isInArrayItemObject: isInArrayItemObject,\n          isInSubObject: true\n        });\n      }\n      /* eslint-enable no-restricted-syntax */\n\n    }\n  }\n\n  function checkModifier(mod) {\n    // Loop through operators\n    Object.keys(mod).forEach(function (op) {\n      var opObj = mod[op]; // If non-operators are mixed in, throw error\n\n      if (op.slice(0, 1) !== '$') {\n        throw new Error(\"Expected '\".concat(op, \"' to be a modifier operator like '$set'\"));\n      }\n\n      if (shouldCheck(op)) {\n        // For an upsert, missing props would not be set if an insert is performed,\n        // so we check them all with undefined value to force any 'required' checks to fail\n        if (isUpsert && (op === '$set' || op === '$setOnInsert')) {\n          var presentKeys = Object.keys(opObj);\n          schema.objectKeys().forEach(function (schemaKey) {\n            if (!presentKeys.includes(schemaKey)) {\n              checkObj({\n                val: undefined,\n                affectedKey: schemaKey,\n                operator: op\n              });\n            }\n          });\n        } // Don't use forEach here because it will not properly handle an\n        // object that has a property named `length`\n\n\n        Object.keys(opObj).forEach(function (k) {\n          var v = opObj[k];\n\n          if (op === '$push' || op === '$addToSet') {\n            if (_typeof(v) === 'object' && '$each' in v) {\n              v = v.$each;\n            } else {\n              k = \"\".concat(k, \".0\");\n            }\n          }\n\n          checkObj({\n            val: v,\n            affectedKey: k,\n            operator: op\n          });\n        });\n      }\n    });\n  } // Kick off the validation\n\n\n  if (isModifier) {\n    checkModifier(obj);\n  } else {\n    checkObj({\n      val: obj\n    });\n  } // Custom whole-doc validators\n\n\n  var docValidators = schema._docValidators.concat(_SimpleSchema.SimpleSchema._docValidators);\n\n  var docValidatorContext = _objectSpread({\n    ignoreTypes: ignoreTypes,\n    isModifier: isModifier,\n    isUpsert: isUpsert,\n    keysToValidate: keysToValidate,\n    mongoObject: mongoObject,\n    obj: obj,\n    schema: schema,\n    validationContext: validationContext\n  }, extendedCustomContext || {});\n\n  docValidators.forEach(function (func) {\n    var errors = func.call(docValidatorContext, obj);\n    if (!Array.isArray(errors)) throw new Error('Custom doc validator must return an array of error objects');\n    if (errors.length) validationErrors = validationErrors.concat(errors);\n  });\n  var addedFieldNames = [];\n  validationErrors = validationErrors.filter(function (errObj) {\n    // Remove error types the user doesn't care about\n    if (ignoreTypes.includes(errObj.type)) return false; // Make sure there is only one error per fieldName\n\n    if (addedFieldNames.includes(errObj.name)) return false;\n    addedFieldNames.push(errObj.name);\n    return true;\n  });\n  return validationErrors;\n}\n\nvar _default = doValidation;\nexports.default = _default;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;"]},"metadata":{},"sourceType":"script"}