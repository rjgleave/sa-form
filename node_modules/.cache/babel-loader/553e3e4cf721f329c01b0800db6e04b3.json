{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ValidationContext\", {\n  enumerable: true,\n  get: function get() {\n    return _ValidationContext.default;\n  }\n});\nexports.SimpleSchema = exports.schemaDefinitionOptions = void 0;\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _messageBox = _interopRequireDefault(require(\"message-box\"));\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _humanize = _interopRequireDefault(require(\"./humanize\"));\n\nvar _ValidationContext = _interopRequireDefault(require(\"./ValidationContext\"));\n\nvar _SimpleSchemaGroup = _interopRequireDefault(require(\"./SimpleSchemaGroup\"));\n\nvar _regExp = _interopRequireDefault(require(\"./regExp\"));\n\nvar _clean2 = _interopRequireDefault(require(\"./clean\"));\n\nvar _expandShorthand = _interopRequireDefault(require(\"./expandShorthand\"));\n\nvar _utility = require(\"./utility\");\n\nvar _defaultMessages = _interopRequireDefault(require(\"./defaultMessages\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Exported for tests\n\n\nvar schemaDefinitionOptions = ['type', 'label', 'optional', 'required', 'autoValue', 'defaultValue'];\nexports.schemaDefinitionOptions = schemaDefinitionOptions;\nvar oneOfProps = ['type', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx', 'custom', 'blackbox', 'trim'];\nvar propsThatCanBeFunction = ['label', 'optional', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx'];\n\nvar SimpleSchema = /*#__PURE__*/function () {\n  function SimpleSchema() {\n    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        check = _ref.check,\n        cleanOptions = _ref.clean,\n        defaultLabel = _ref.defaultLabel,\n        _ref$humanizeAutoLabe = _ref.humanizeAutoLabels,\n        humanizeAutoLabels = _ref$humanizeAutoLabe === void 0 ? true : _ref$humanizeAutoLabe,\n        _ref$requiredByDefaul = _ref.requiredByDefault,\n        requiredByDefault = _ref$requiredByDefaul === void 0 ? true : _ref$requiredByDefaul,\n        tracker = _ref.tracker;\n\n    _classCallCheck(this, SimpleSchema);\n\n    _defineProperty(this, \"pick\", getPickOrOmit('pick'));\n\n    _defineProperty(this, \"omit\", getPickOrOmit('omit')); // Stash the options object\n\n\n    this._constructorOptions = {\n      check: check,\n      defaultLabel: defaultLabel,\n      humanizeAutoLabels: humanizeAutoLabels,\n      requiredByDefault: requiredByDefault,\n      tracker: tracker\n    }; // Custom validators for this instance\n\n    this._validators = [];\n    this._docValidators = []; // Named validation contexts\n\n    this._validationContexts = {}; // Schema-level defaults for cleaning\n\n    this._cleanOptions = _objectSpread({\n      filter: true,\n      autoConvert: true,\n      removeEmptyStrings: true,\n      trimStrings: true,\n      getAutoValues: true,\n      removeNullsFromArrays: false,\n      extendAutoValueContext: {}\n    }, cleanOptions); // Clone, expanding shorthand, and store the schema object in this._schema\n\n    this._schema = {};\n    this._depsLabels = {};\n    this.extend(schema); // Define default validation error messages\n\n    this.messageBox = new _messageBox.default((0, _clone.default)(_defaultMessages.default));\n    this.version = SimpleSchema.version;\n  }\n\n  _createClass(SimpleSchema, [{\n    key: \"forEachAncestorSimpleSchema\",\n    value: function forEachAncestorSimpleSchema(key, func) {\n      var _this = this;\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key);\n\n      (0, _utility.forEachKeyAncestor)(genericKey, function (ancestor) {\n        var def = _this._schema[ancestor];\n        if (!def) return;\n        def.type.definitions.forEach(function (typeDef) {\n          if (SimpleSchema.isSimpleSchema(typeDef.type)) {\n            func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\n          }\n        });\n      });\n    }\n    /**\n     * Returns whether the obj is a SimpleSchema object.\n     * @param {Object} [obj] An object to test\n     * @returns {Boolean} True if the given object appears to be a SimpleSchema instance\n     */\n\n  }, {\n    key: \"reactiveLabelDependency\",\n\n    /**\n     * For Meteor apps, add a reactive dependency on the label\n     * for a key.\n     */\n    value: function reactiveLabelDependency(key) {\n      var tracker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._constructorOptions.tracker;\n      if (!key || !tracker) return;\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key); // If in this schema\n\n\n      if (this._schema[genericKey]) {\n        if (!this._depsLabels[genericKey]) {\n          this._depsLabels[genericKey] = new tracker.Dependency();\n        }\n\n        this._depsLabels[genericKey].depend();\n\n        return;\n      } // If in subschema\n\n\n      this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n        // Pass tracker down so that we get reactivity even if the subschema\n        // didn't have tracker option set\n        simpleSchema.reactiveLabelDependency(subSchemaKey, tracker);\n      });\n    }\n    /**\n     * @param {String} [key] One specific or generic key for which to get the schema.\n     * @returns {Object} The entire schema object or just the definition for one key.\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"schema\",\n    value: function schema(key) {\n      if (!key) return this._schema;\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key);\n\n      var keySchema = this._schema[genericKey]; // If not defined in this schema, see if it's defined in a subschema\n\n      if (!keySchema) {\n        var found = false;\n        this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n          if (!found) keySchema = simpleSchema.schema(subSchemaKey);\n          if (keySchema) found = true;\n        });\n      }\n\n      return keySchema;\n    }\n    /**\n     * @returns {Object} The entire schema object with subschemas merged. This is the\n     * equivalent of what schema() returned in SimpleSchema < 2.0\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"mergedSchema\",\n    value: function mergedSchema() {\n      var _this2 = this;\n\n      var mergedSchema = {};\n\n      this._schemaKeys.forEach(function (key) {\n        var keySchema = _this2._schema[key];\n        mergedSchema[key] = keySchema;\n        keySchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          var childSchema = typeDef.type.mergedSchema();\n          Object.keys(childSchema).forEach(function (subKey) {\n            mergedSchema[\"\".concat(key, \".\").concat(subKey)] = childSchema[subKey];\n          });\n        });\n      });\n\n      return mergedSchema;\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param {String} key Generic or specific schema key\n     * @param {Array(String)} [propList] Array of schema properties you need; performance optimization\n     * @param {Object} [functionContext] The context to use when evaluating schema options that are functions\n     * @returns {Object} The schema definition for the requested key\n     */\n\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(key, propList) {\n      var _this3 = this;\n\n      var functionContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var defs = this.schema(key);\n      if (!defs) return;\n\n      var getPropIterator = function getPropIterator(obj, newObj) {\n        return function (prop) {\n          if (Array.isArray(propList) && !propList.includes(prop)) return;\n          var val = obj[prop]; // For any options that support specifying a function, evaluate the functions\n\n          if (propsThatCanBeFunction.indexOf(prop) > -1 && typeof val === 'function') {\n            newObj[prop] = val.call(_objectSpread({\n              key: key\n            }, functionContext)); // Inflect label if undefined\n\n            if (prop === 'label' && typeof newObj[prop] !== 'string') newObj[prop] = inflectedLabel(key, _this3._constructorOptions.humanizeAutoLabels);\n          } else {\n            newObj[prop] = val;\n          }\n        };\n      };\n\n      var result = {};\n      Object.keys(defs).forEach(getPropIterator(defs, result)); // Resolve all the types and convert to a normal array to make it easier\n      // to use.\n\n      if (defs.type) {\n        result.type = defs.type.definitions.map(function (typeDef) {\n          var newTypeDef = {};\n          Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\n          return newTypeDef;\n        });\n      }\n\n      return result;\n    }\n    /**\n     * Returns a string identifying the best guess data type for a key. For keys\n     * that allow multiple types, the first type is used. This can be useful for\n     * building forms.\n     *\n     * @param {String} key Generic or specific schema key\n     * @returns {String} A type string. One of:\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\n     *  dateArray, objectArray\n     */\n\n  }, {\n    key: \"getQuickTypeForKey\",\n    value: function getQuickTypeForKey(key) {\n      var type;\n      var fieldSchema = this.schema(key);\n      if (!fieldSchema) return;\n      var fieldType = fieldSchema.type.singleType;\n\n      if (fieldType === String) {\n        type = 'string';\n      } else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\n        type = 'number';\n      } else if (fieldType === Boolean) {\n        type = 'boolean';\n      } else if (fieldType === Date) {\n        type = 'date';\n      } else if (fieldType === Array) {\n        var arrayItemFieldSchema = this.schema(\"\".concat(key, \".$\"));\n        if (!arrayItemFieldSchema) return;\n        var arrayItemFieldType = arrayItemFieldSchema.type.singleType;\n\n        if (arrayItemFieldType === String) {\n          type = 'stringArray';\n        } else if (arrayItemFieldType === Number || arrayItemFieldType === SimpleSchema.Integer) {\n          type = 'numberArray';\n        } else if (arrayItemFieldType === Boolean) {\n          type = 'booleanArray';\n        } else if (arrayItemFieldType === Date) {\n          type = 'dateArray';\n        } else if (arrayItemFieldType === Object || SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\n          type = 'objectArray';\n        }\n      } else if (fieldType === Object) {\n        type = 'object';\n      }\n\n      return type;\n    }\n    /**\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\n     *\n     * @param {String} key Generic or specific schema key\n     */\n\n  }, {\n    key: \"getObjectSchema\",\n    value: function getObjectSchema(key) {\n      var newSchemaDef = {};\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key);\n\n      var searchString = \"\".concat(genericKey, \".\");\n      var mergedSchema = this.mergedSchema();\n      Object.keys(mergedSchema).forEach(function (k) {\n        if (k.indexOf(searchString) === 0) {\n          newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\n        }\n      });\n      return this._copyWithSchema(newSchemaDef);\n    } // Returns an array of all the autovalue functions, including those in subschemas all the\n    // way down the schema tree\n\n  }, {\n    key: \"autoValueFunctions\",\n    value: function autoValueFunctions() {\n      var _this4 = this;\n\n      var result = [].concat(this._autoValues);\n\n      this._schemaKeys.forEach(function (key) {\n        _this4._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          result = result.concat(typeDef.type.autoValueFunctions().map(function (_ref2) {\n            var func = _ref2.func,\n                fieldName = _ref2.fieldName,\n                closestSubschemaFieldName = _ref2.closestSubschemaFieldName;\n            return {\n              func: func,\n              fieldName: \"\".concat(key, \".\").concat(fieldName),\n              closestSubschemaFieldName: closestSubschemaFieldName.length ? \"\".concat(key, \".\").concat(closestSubschemaFieldName) : key\n            };\n          }));\n        });\n      });\n\n      return result;\n    } // Returns an array of all the blackbox keys, including those in subschemas\n\n  }, {\n    key: \"blackboxKeys\",\n    value: function blackboxKeys() {\n      var _this5 = this;\n\n      var blackboxKeys = new Set(this._blackboxKeys);\n\n      this._schemaKeys.forEach(function (key) {\n        _this5._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          typeDef.type.blackboxKeys().forEach(function (blackboxKey) {\n            blackboxKeys.add(\"\".concat(key, \".\").concat(blackboxKey));\n          });\n        });\n      });\n\n      return Array.from(blackboxKeys);\n    } // Check if the key is a nested dot-syntax key inside of a blackbox object\n\n  }, {\n    key: \"keyIsInBlackBox\",\n    value: function keyIsInBlackBox(key) {\n      var _this6 = this;\n\n      var isInBlackBox = false;\n      (0, _utility.forEachKeyAncestor)(_mongoObject.default.makeKeyGeneric(key), function (ancestor, remainder) {\n        if (_this6._blackboxKeys.has(ancestor)) {\n          isInBlackBox = true;\n        } else {\n          var testKeySchema = _this6.schema(ancestor);\n\n          if (testKeySchema) {\n            testKeySchema.type.definitions.forEach(function (typeDef) {\n              if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n              if (typeDef.type.keyIsInBlackBox(remainder)) isInBlackBox = true;\n            });\n          }\n        }\n      });\n      return isInBlackBox;\n    } // Returns true if key is explicitly allowed by the schema or implied\n    // by other explicitly allowed keys.\n    // The key string should have $ in place of any numeric array positions.\n\n  }, {\n    key: \"allowsKey\",\n    value: function allowsKey(key) {\n      var _this7 = this; // Loop through all keys in the schema\n\n\n      return this._schemaKeys.some(function (loopKey) {\n        // If the schema key is the test key, it's allowed.\n        if (loopKey === key) return true;\n\n        var fieldSchema = _this7.schema(loopKey);\n\n        var compare1 = key.slice(0, loopKey.length + 2);\n        var compare2 = compare1.slice(0, -1); // Blackbox and subschema checks are needed only if key starts with\n        // loopKey + a dot\n\n        if (compare2 !== \"\".concat(loopKey, \".\")) return false; // Black box handling\n\n        if (_this7._blackboxKeys.has(loopKey)) {\n          // If the test key is the black box key + \".$\", then the test\n          // key is NOT allowed because black box keys are by definition\n          // only for objects, and not for arrays.\n          return compare1 !== \"\".concat(loopKey, \".$\");\n        } // Subschemas\n\n\n        var allowed = false;\n        var subKey = key.slice(loopKey.length + 1);\n        fieldSchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          if (typeDef.type.allowsKey(subKey)) allowed = true;\n        });\n        return allowed;\n      });\n    }\n    /**\n     * Returns all the child keys for the object identified by the generic prefix,\n     * or all the top level keys if no prefix is supplied.\n     *\n     * @param {String} [keyPrefix] The Object-type generic key for which to get child keys. Omit for\n     *   top-level Object-type keys\n     * @returns {[[Type]]} [[Description]]\n     */\n\n  }, {\n    key: \"objectKeys\",\n    value: function objectKeys(keyPrefix) {\n      if (!keyPrefix) return this._firstLevelSchemaKeys;\n      return this._objectKeys[\"\".concat(keyPrefix, \".\")] || [];\n    }\n    /**\n     * Copies this schema into a new instance with the same validators, messages,\n     * and options, but with different keys as defined in `schema` argument\n     *\n     * @param {Object} schema\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"_copyWithSchema\",\n    value: function _copyWithSchema(schema) {\n      var cl = new SimpleSchema(schema, _objectSpread({}, this._constructorOptions));\n      cl._cleanOptions = this._cleanOptions;\n      cl.messageBox = this.messageBox.clone();\n      return cl;\n    }\n    /**\n     * Clones this schema into a new instance with the same schema keys, validators,\n     * and options.\n     *\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this._copyWithSchema(this._schema);\n    }\n    /**\n     * Extends (mutates) this schema with another schema, key by key.\n     *\n     * @param {SimpleSchema|Object} schema\n     * @returns The SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var _this8 = this;\n\n      var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (Array.isArray(schema)) throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\n      var schemaObj;\n\n      if (SimpleSchema.isSimpleSchema(schema)) {\n        schemaObj = schema._schema;\n        this._validators = this._validators.concat(schema._validators);\n        this._docValidators = this._docValidators.concat(schema._docValidators);\n        Object.assign(this._cleanOptions, schema._cleanOptions);\n        Object.assign(this._constructorOptions, schema._constructorOptions);\n      } else {\n        schemaObj = (0, _expandShorthand.default)(schema);\n      } // Update all of the information cached on the instance\n\n\n      Object.keys(schemaObj).forEach(function (fieldName) {\n        var definition = standardizeDefinition(schemaObj[fieldName]); // Merge/extend with any existing definition\n\n        if (_this8._schema[fieldName]) {\n          if (!Object.prototype.hasOwnProperty.call(_this8._schema, fieldName)) {\n            // fieldName is actually a method from Object itself!\n            throw new Error(\"\".concat(fieldName, \" key is actually the name of a method on Object, please rename it\"));\n          }\n\n          var type = definition.type,\n              definitionWithoutType = _objectWithoutProperties(definition, [\"type\"]); // eslint-disable-line no-unused-vars\n\n\n          _this8._schema[fieldName] = _objectSpread({}, _this8._schema[fieldName], {}, definitionWithoutType);\n          if (definition.type) _this8._schema[fieldName].type.extend(definition.type);\n        } else {\n          _this8._schema[fieldName] = definition;\n        }\n\n        checkAndScrubDefinition(fieldName, _this8._schema[fieldName], _this8._constructorOptions, schemaObj);\n      });\n      checkSchemaOverlap(this._schema); // Set/Reset all of these\n\n      this._schemaKeys = Object.keys(this._schema);\n      this._autoValues = [];\n      this._blackboxKeys = new Set();\n      this._firstLevelSchemaKeys = [];\n      this._objectKeys = {}; // Update all of the information cached on the instance\n\n      this._schemaKeys.forEach(function (fieldName) {\n        // Make sure parent has a definition in the schema. No implied objects!\n        if (fieldName.indexOf('.') > -1) {\n          var parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\n          if (!Object.prototype.hasOwnProperty.call(_this8._schema, parentFieldName)) throw new Error(\"\\\"\".concat(fieldName, \"\\\" is in the schema but \\\"\").concat(parentFieldName, \"\\\" is not\"));\n        }\n\n        var definition = _this8._schema[fieldName]; // Keep list of all top level keys\n\n        if (fieldName.indexOf('.') === -1) _this8._firstLevelSchemaKeys.push(fieldName); // Keep list of all blackbox keys for passing to MongoObject constructor\n        // XXX For now if any oneOf type is blackbox, then the whole field is.\n\n        /* eslint-disable no-restricted-syntax */\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = definition.type.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var oneOfDef = _step.value; // XXX If the type is SS.Any, also consider it a blackbox\n\n            if (oneOfDef.blackbox === true || oneOfDef.type === SimpleSchema.Any) {\n              _this8._blackboxKeys.add(fieldName);\n\n              break;\n            }\n          }\n          /* eslint-enable no-restricted-syntax */\n          // Keep list of autoValue functions\n\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (typeof definition.autoValue === 'function') {\n          _this8._autoValues.push({\n            closestSubschemaFieldName: '',\n            fieldName: fieldName,\n            func: definition.autoValue\n          });\n        }\n      }); // Store child keys keyed by parent. This needs to be done recursively to handle\n      // subschemas.\n\n\n      var setObjectKeys = function setObjectKeys(curSchema, schemaParentKey) {\n        Object.keys(curSchema).forEach(function (fieldName) {\n          var definition = curSchema[fieldName];\n          fieldName = schemaParentKey ? \"\".concat(schemaParentKey, \".\").concat(fieldName) : fieldName;\n\n          if (fieldName.indexOf('.') > -1 && fieldName.slice(-2) !== '.$') {\n            var parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\n            var parentKeyWithDot = \"\".concat(parentKey, \".\");\n            _this8._objectKeys[parentKeyWithDot] = _this8._objectKeys[parentKeyWithDot] || [];\n\n            _this8._objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\n          } // If the current field is a nested SimpleSchema,\n          // iterate over the child fields and cache their properties as well\n\n\n          definition.type.definitions.forEach(function (_ref3) {\n            var type = _ref3.type;\n\n            if (SimpleSchema.isSimpleSchema(type)) {\n              setObjectKeys(type._schema, fieldName);\n            }\n          });\n        });\n      };\n\n      setObjectKeys(this._schema);\n      return this;\n    }\n  }, {\n    key: \"getAllowedValuesForKey\",\n    value: function getAllowedValuesForKey(key) {\n      // For array fields, `allowedValues` is on the array item definition\n      if (this.allowsKey(\"\".concat(key, \".$\"))) {\n        key = \"\".concat(key, \".$\");\n      }\n\n      var allowedValues = this.get(key, 'allowedValues');\n\n      if (Array.isArray(allowedValues) || allowedValues instanceof Set) {\n        return _toConsumableArray(allowedValues);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"newContext\",\n    value: function newContext() {\n      return new _ValidationContext.default(this);\n    }\n  }, {\n    key: \"namedContext\",\n    value: function namedContext(name) {\n      if (typeof name !== 'string') name = 'default';\n\n      if (!this._validationContexts[name]) {\n        this._validationContexts[name] = new _ValidationContext.default(this);\n      }\n\n      return this._validationContexts[name];\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      this._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      this._docValidators.push(func);\n    }\n    /**\n     * @param obj {Object|Object[]} Object or array of objects to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(obj) {\n      var _this9 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // For Meteor apps, `check` option can be passed to silence audit-argument-checks\n\n      var check = options.check || this._constructorOptions.check;\n\n      if (typeof check === 'function') {\n        // Call check but ignore the error\n        try {\n          check(obj);\n        } catch (e) {\n          /* ignore error */\n        }\n      } // obj can be an array, in which case we validate each object in it and\n      // throw as soon as one has an error\n\n\n      var objects = Array.isArray(obj) ? obj : [obj];\n      objects.forEach(function (oneObj) {\n        var validationContext = _this9.newContext();\n\n        var isValid = validationContext.validate(oneObj, options);\n        if (isValid) return;\n        var errors = validationContext.validationErrors(); // In order for the message at the top of the stack trace to be useful,\n        // we set it to the first validation error message.\n\n        var message = _this9.messageForError(errors[0]);\n\n        var error = new Error(message);\n        error.errorType = 'ClientError';\n        error.name = 'ClientError';\n        error.error = 'validation-error'; // Add meaningful error messages for each validation error.\n        // Useful for display messages when using 'mdg:validated-method'.\n\n        error.details = errors.map(function (errorDetail) {\n          return _objectSpread({}, errorDetail, {\n            message: _this9.messageForError(errorDetail)\n          });\n        }); // The primary use for the validationErrorTransform is to convert the\n        // vanilla Error into a Meteor.Error until DDP is able to pass\n        // vanilla errors back to the client.\n\n        if (typeof SimpleSchema.validationErrorTransform === 'function') {\n          throw SimpleSchema.validationErrorTransform(error);\n        } else {\n          throw error;\n        }\n      });\n    }\n    /**\n     * @param obj {Object} Object to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Returns a Promise that resolves with the errors\n     */\n\n  }, {\n    key: \"validateAndReturnErrorsPromise\",\n    value: function validateAndReturnErrorsPromise(obj, options) {\n      var _this10 = this;\n\n      var validationContext = this.newContext();\n      var isValid = validationContext.validate(obj, options);\n      if (isValid) return Promise.resolve([]); // Add the `message` prop\n\n      var errors = validationContext.validationErrors().map(function (errorDetail) {\n        return _objectSpread({}, errorDetail, {\n          message: _this10.messageForError(errorDetail)\n        });\n      });\n      return Promise.resolve(errors);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var _this11 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function (obj) {\n        var optionsClone = _objectSpread({}, options);\n\n        if (options.clean === true) {\n          // Do this here and pass into both functions for better performance\n          optionsClone.mongoObject = new _mongoObject.default(obj, _this11.blackboxKeys());\n\n          _this11.clean(obj, optionsClone);\n        }\n\n        if (options.returnErrorsPromise) {\n          return _this11.validateAndReturnErrorsPromise(obj, optionsClone);\n        }\n\n        return _this11.validate(obj, optionsClone);\n      };\n    }\n  }, {\n    key: \"getFormValidator\",\n    value: function getFormValidator() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.validator(_objectSpread({}, options, {\n        returnErrorsPromise: true\n      }));\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _clean2.default.apply(void 0, [this].concat(args));\n    }\n    /**\n     * Change schema labels on the fly, causing mySchema.label computation\n     * to rerun. Useful when the user changes the language.\n     *\n     * @param {Object} labels A dictionary of all the new label values, by schema key.\n     */\n\n  }, {\n    key: \"labels\",\n    value: function labels(_labels) {\n      var _this12 = this;\n\n      Object.keys(_labels).forEach(function (key) {\n        var label = _labels[key];\n        if (typeof label !== 'string' && typeof label !== 'function') return;\n        if (!Object.prototype.hasOwnProperty.call(_this12._schema, key)) return;\n        _this12._schema[key].label = label;\n        _this12._depsLabels[key] && _this12._depsLabels[key].changed();\n      });\n    }\n    /**\n     * Gets a field's label or all field labels reactively.\n     *\n     * @param {String} [key] The schema key, specific or generic.\n     *   Omit this argument to get a dictionary of all labels.\n     * @returns {String} The label\n     */\n\n  }, {\n    key: \"label\",\n    value: function label(key) {\n      var _this13 = this; // Get all labels\n\n\n      if (key === null || key === undefined) {\n        var result = {};\n\n        this._schemaKeys.forEach(function (schemaKey) {\n          result[schemaKey] = _this13.label(schemaKey);\n        });\n\n        return result;\n      } // Get label for one field\n\n\n      var label = this.get(key, 'label');\n      if (label) this.reactiveLabelDependency(key);\n      return label || null;\n    }\n    /**\n     * Gets a field's property\n     *\n     * @param {String} key The schema key, specific or generic.\n     * @param {String} prop Name of the property to get for that schema key\n     * @param {Object} [functionContext] The `this` context to use if prop is a function\n     * @returns {any} The property value\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, prop, functionContext) {\n      var def = this.getDefinition(key, ['type', prop], functionContext);\n      if (!def) return undefined;\n\n      if (schemaDefinitionOptions.includes(prop)) {\n        return def[prop];\n      }\n\n      return (def.type.find(function (props) {\n        return props[prop];\n      }) || {})[prop];\n    } // shorthand for getting defaultValue\n\n  }, {\n    key: \"defaultValue\",\n    value: function defaultValue(key) {\n      return this.get(key, 'defaultValue');\n    } // Returns a string message for the given error type and key. Passes through\n    // to message-box pkg.\n\n  }, {\n    key: \"messageForError\",\n    value: function messageForError(errorInfo) {\n      var name = errorInfo.name;\n      return this.messageBox.message(errorInfo, {\n        context: {\n          key: name,\n          // backward compatibility\n          // The call to this.label() establishes a reactive dependency, too\n          label: this.label(name)\n        }\n      });\n    }\n    /**\n     * @method SimpleSchema#pick\n     * @param {[fields]} The list of fields to pick to instantiate the subschema\n     * @returns {SimpleSchema} The subschema\n     */\n\n  }], [{\n    key: \"isSimpleSchema\",\n    value: function isSimpleSchema(obj) {\n      return obj && (obj instanceof SimpleSchema || obj._schema);\n    }\n  }, {\n    key: \"extendOptions\",\n    // If you need to allow properties other than those listed above, call this from your app or package\n    value: function extendOptions(options) {\n      // For backwards compatibility we still take an object here, but we only care about the names\n      if (!Array.isArray(options)) options = Object.keys(options);\n      options.forEach(function (option) {\n        schemaDefinitionOptions.push(option);\n      });\n    }\n  }, {\n    key: \"defineValidationErrorTransform\",\n    value: function defineValidationErrorTransform(transform) {\n      if (typeof transform !== 'function') {\n        throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\n      }\n\n      SimpleSchema.validationErrorTransform = transform;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(obj, schema, options) {\n      // Allow passing just the schema object\n      if (!SimpleSchema.isSimpleSchema(schema)) {\n        schema = new SimpleSchema(schema);\n      }\n\n      return schema.validate(obj, options);\n    }\n  }, {\n    key: \"oneOf\",\n    value: function oneOf() {\n      for (var _len2 = arguments.length, definitions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        definitions[_key2] = arguments[_key2];\n      }\n\n      return _construct(_SimpleSchemaGroup.default, definitions);\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      SimpleSchema._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      SimpleSchema._docValidators.push(func);\n    }\n  }]);\n\n  return SimpleSchema;\n}();\n/*\n * PRIVATE\n */\n// Throws an error if any fields are `type` SimpleSchema but then also\n// have subfields defined outside of that.\n\n\nexports.SimpleSchema = SimpleSchema;\n\n_defineProperty(SimpleSchema, \"version\", 2);\n\n_defineProperty(SimpleSchema, \"Any\", '___Any___');\n\n_defineProperty(SimpleSchema, \"RegEx\", _regExp.default);\n\n_defineProperty(SimpleSchema, \"_validators\", []);\n\n_defineProperty(SimpleSchema, \"_docValidators\", []);\n\n_defineProperty(SimpleSchema, \"ErrorTypes\", {\n  REQUIRED: 'required',\n  MIN_STRING: 'minString',\n  MAX_STRING: 'maxString',\n  MIN_NUMBER: 'minNumber',\n  MAX_NUMBER: 'maxNumber',\n  MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\n  MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\n  MIN_DATE: 'minDate',\n  MAX_DATE: 'maxDate',\n  BAD_DATE: 'badDate',\n  MIN_COUNT: 'minCount',\n  MAX_COUNT: 'maxCount',\n  MUST_BE_INTEGER: 'noDecimal',\n  VALUE_NOT_ALLOWED: 'notAllowed',\n  EXPECTED_TYPE: 'expectedType',\n  FAILED_REGULAR_EXPRESSION: 'regEx',\n  KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\n});\n\n_defineProperty(SimpleSchema, \"Integer\", 'SimpleSchema.Integer');\n\n_defineProperty(SimpleSchema, \"_makeGeneric\", _mongoObject.default.makeKeyGeneric);\n\n_defineProperty(SimpleSchema, \"ValidationContext\", _ValidationContext.default);\n\n_defineProperty(SimpleSchema, \"setDefaultMessages\", function (messages) {\n  (0, _utility.merge)(_defaultMessages.default, messages);\n});\n\nfunction checkSchemaOverlap(schema) {\n  Object.keys(schema).forEach(function (key) {\n    var val = schema[key];\n    if (!val.type) throw new Error(\"\".concat(key, \" key is missing \\\"type\\\"\"));\n    val.type.definitions.forEach(function (def) {\n      if (!SimpleSchema.isSimpleSchema(def.type)) return;\n      Object.keys(def.type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(key, \".\").concat(subKey);\n\n        if (Object.prototype.hasOwnProperty.call(schema, newKey)) {\n          throw new Error(\"The type for \\\"\".concat(key, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(key, \".\").concat(subKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(key, \".\").concat(subKey, \"\\\"\"));\n        }\n      });\n    });\n  });\n}\n/**\n * @param {String} fieldName The full generic schema key\n * @param {Boolean} shouldHumanize Humanize it\n * @returns {String} A label based on the key\n */\n\n\nfunction inflectedLabel(fieldName, shouldHumanize) {\n  var pieces = fieldName.split('.');\n  var label;\n\n  do {\n    label = pieces.pop();\n  } while (label === '$' && pieces.length);\n\n  return shouldHumanize ? (0, _humanize.default)(label) : label;\n}\n\nfunction getDefaultAutoValueFunction(defaultValue) {\n  return function defaultAutoValueFunction() {\n    if (this.isSet) return;\n    if (this.operator === null) return defaultValue; // Handle the case when pulling an object from an array the object contains a field\n    // which has a defaultValue. We don't want the default value to be returned in this case\n\n    if (this.operator === '$pull') return; // Handle the case where we are $pushing an object into an array of objects and we\n    // want any fields missing from that object to be added if they have default values\n\n    if (this.operator === '$push') return defaultValue; // If parent is set, we should update this position instead of $setOnInsert\n\n    if (this.parentField().isSet) return defaultValue; // Make sure the default value is added on upsert insert\n\n    if (this.isUpsert) return {\n      $setOnInsert: defaultValue\n    };\n  };\n} // Mutates def into standardized object with SimpleSchemaGroup type\n\n\nfunction standardizeDefinition(def) {\n  var standardizedDef = Object.keys(def).reduce(function (newDef, prop) {\n    if (!oneOfProps.includes(prop)) {\n      newDef[prop] = def[prop];\n    }\n\n    return newDef;\n  }, {}); // Internally, all definition types are stored as groups for simplicity of access.\n  // If we are extending, there may not actually be def.type, but it's okay because\n  // it will be added later when the two SimpleSchemaGroups are merged.\n\n  if (def.type && def.type instanceof _SimpleSchemaGroup.default) {\n    standardizedDef.type = def.type.clone();\n  } else {\n    var groupProps = Object.keys(def).reduce(function (newDef, prop) {\n      if (oneOfProps.includes(prop)) {\n        newDef[prop] = def[prop];\n      }\n\n      return newDef;\n    }, {});\n    standardizedDef.type = new _SimpleSchemaGroup.default(groupProps);\n  }\n\n  return standardizedDef;\n} // Checks and mutates definition. Clone it first.\n\n\nfunction checkAndScrubDefinition(fieldName, definition, options, fullSchemaObj) {\n  if (!definition.type) throw new Error(\"\".concat(fieldName, \" key is missing \\\"type\\\"\")); // Validate the field definition\n\n  Object.keys(definition).forEach(function (key) {\n    if (schemaDefinitionOptions.indexOf(key) === -1) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"\").concat(key, \"\\\" is not a supported property\"));\n    }\n  }); // Make sure the `type`s are OK\n\n  var couldBeArray = false;\n  definition.type.definitions.forEach(function (_ref4) {\n    var type = _ref4.type;\n    if (!type) throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" option is required\"));\n\n    if (Array.isArray(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an array. Change it to Array.\"));\n    }\n\n    if (type.constructor === Object && (0, _utility.isEmptyObject)(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an object. Change it to Object\"));\n    }\n\n    if (type === Array) couldBeArray = true;\n\n    if (SimpleSchema.isSimpleSchema(type)) {\n      Object.keys(type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(fieldName, \".\").concat(subKey);\n\n        if (Object.prototype.hasOwnProperty.call(fullSchemaObj, newKey)) {\n          throw new Error(\"The type for \\\"\".concat(fieldName, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(newKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(newKey, \"\\\"\"));\n        }\n      });\n    }\n  }); // If at least one of the possible types is Array, then make sure we have a\n  // definition for the array items, too.\n\n  if (couldBeArray && !Object.prototype.hasOwnProperty.call(fullSchemaObj, \"\".concat(fieldName, \".$\"))) {\n    throw new Error(\"\\\"\".concat(fieldName, \"\\\" is Array type but the schema does not include a \\\"\").concat(fieldName, \".$\\\" definition for the array items\\\"\"));\n  } // defaultValue -> autoValue\n  // We support defaultValue shortcut by converting it immediately into an\n  // autoValue.\n\n\n  if ('defaultValue' in definition) {\n    if ('autoValue' in definition && !definition.autoValue.isDefault) {\n      console.warn(\"SimpleSchema: Found both autoValue and defaultValue options for \\\"\".concat(fieldName, \"\\\". Ignoring defaultValue.\"));\n    } else {\n      if (fieldName.endsWith('.$')) {\n        throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n      }\n\n      definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\n      definition.autoValue.isDefault = true;\n    }\n  } // REQUIREDNESS\n\n\n  if (fieldName.endsWith('.$')) {\n    definition.optional = true;\n  } else if (!Object.prototype.hasOwnProperty.call(definition, 'optional')) {\n    if (Object.prototype.hasOwnProperty.call(definition, 'required')) {\n      if (typeof definition.required === 'function') {\n        definition.optional = function optional() {\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          return !definition.required.apply(this, args);\n        };\n      } else {\n        definition.optional = !definition.required;\n      }\n    } else {\n      definition.optional = options.requiredByDefault === false;\n    }\n  }\n\n  delete definition.required; // LABELS\n\n  if (!Object.prototype.hasOwnProperty.call(definition, 'label')) {\n    if (options.defaultLabel) {\n      definition.label = options.defaultLabel;\n    } else if (SimpleSchema.defaultLabel) {\n      definition.label = SimpleSchema.defaultLabel;\n    } else {\n      definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\n    }\n  }\n}\n\nfunction getPickOrOmit(type) {\n  return function pickOrOmit() {\n    var _this14 = this;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    } // If they are picking/omitting an object or array field, we need to also include everything under it\n\n\n    var newSchema = {};\n\n    this._schemaKeys.forEach(function (key) {\n      // Pick/omit it if it IS in the array of keys they want OR if it\n      // STARTS WITH something that is in the array plus a period\n      var includeIt = args.some(function (wantedField) {\n        return key === wantedField || key.indexOf(\"\".concat(wantedField, \".\")) === 0;\n      });\n\n      if (includeIt && type === 'pick' || !includeIt && type === 'omit') {\n        newSchema[key] = _this14._schema[key];\n      }\n    });\n\n    return this._copyWithSchema(newSchema);\n  };\n}","map":{"version":3,"sources":["/Users/rjgleave/mysrc/oneq-work/sa-form/node_modules/simpl-schema/dist/SimpleSchema.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_ValidationContext","default","SimpleSchema","schemaDefinitionOptions","_clone","_interopRequireDefault","require","_messageBox","_mongoObject","_humanize","_SimpleSchemaGroup","_regExp","_clean2","_expandShorthand","_utility","_defaultMessages","obj","__esModule","isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","prototype","toString","call","e","_construct","Parent","args","Class","a","push","apply","Constructor","Function","bind","instance","_setPrototypeOf","arguments","o","p","setPrototypeOf","__proto__","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","i","arr2","length","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","getOwnPropertySymbols","sourceSymbolKeys","indexOf","propertyIsEnumerable","sourceKeys","keys","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","_classCallCheck","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","oneOfProps","propsThatCanBeFunction","schema","undefined","_ref","check","cleanOptions","clean","defaultLabel","_ref$humanizeAutoLabe","humanizeAutoLabels","_ref$requiredByDefaul","requiredByDefault","tracker","getPickOrOmit","_constructorOptions","_validators","_docValidators","_validationContexts","_cleanOptions","autoConvert","removeEmptyStrings","trimStrings","getAutoValues","removeNullsFromArrays","extendAutoValueContext","_schema","_depsLabels","extend","messageBox","version","forEachAncestorSimpleSchema","func","_this","genericKey","makeKeyGeneric","forEachKeyAncestor","ancestor","def","type","definitions","typeDef","isSimpleSchema","slice","reactiveLabelDependency","Dependency","depend","simpleSchema","subSchemaKey","keySchema","found","mergedSchema","_this2","_schemaKeys","childSchema","subKey","concat","getDefinition","propList","_this3","functionContext","defs","getPropIterator","newObj","prop","includes","val","inflectedLabel","result","map","newTypeDef","getQuickTypeForKey","fieldSchema","fieldType","singleType","String","Number","Integer","Boolean","arrayItemFieldSchema","arrayItemFieldType","getObjectSchema","newSchemaDef","searchString","k","_copyWithSchema","autoValueFunctions","_this4","_autoValues","_ref2","fieldName","closestSubschemaFieldName","blackboxKeys","_this5","Set","_blackboxKeys","blackboxKey","add","keyIsInBlackBox","_this6","isInBlackBox","remainder","has","testKeySchema","allowsKey","_this7","some","loopKey","compare1","compare2","allowed","objectKeys","keyPrefix","_firstLevelSchemaKeys","_objectKeys","cl","clone","_this8","Error","schemaObj","assign","definition","standardizeDefinition","hasOwnProperty","definitionWithoutType","checkAndScrubDefinition","checkSchemaOverlap","parentFieldName","lastIndexOf","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","oneOfDef","blackbox","Any","err","return","autoValue","setObjectKeys","curSchema","schemaParentKey","parentKey","parentKeyWithDot","_ref3","getAllowedValuesForKey","allowedValues","newContext","namedContext","name","addValidator","addDocValidator","validate","_this9","options","objects","oneObj","validationContext","isValid","errors","validationErrors","message","messageForError","error","errorType","details","errorDetail","validationErrorTransform","validateAndReturnErrorsPromise","_this10","Promise","resolve","validator","_this11","optionsClone","mongoObject","returnErrorsPromise","getFormValidator","_len","_key","labels","_labels","_this12","label","changed","_this13","schemaKey","find","defaultValue","errorInfo","context","extendOptions","option","defineValidationErrorTransform","transform","oneOf","_len2","_key2","REQUIRED","MIN_STRING","MAX_STRING","MIN_NUMBER","MAX_NUMBER","MIN_NUMBER_EXCLUSIVE","MAX_NUMBER_EXCLUSIVE","MIN_DATE","MAX_DATE","BAD_DATE","MIN_COUNT","MAX_COUNT","MUST_BE_INTEGER","VALUE_NOT_ALLOWED","EXPECTED_TYPE","FAILED_REGULAR_EXPRESSION","KEY_NOT_IN_SCHEMA","messages","merge","newKey","shouldHumanize","pieces","split","pop","getDefaultAutoValueFunction","defaultAutoValueFunction","isSet","operator","parentField","isUpsert","$setOnInsert","standardizedDef","reduce","newDef","groupProps","fullSchemaObj","couldBeArray","_ref4","constructor","isEmptyObject","isDefault","console","warn","endsWith","optional","required","_len3","_key3","pickOrOmit","_this14","_len4","_key4","newSchema","includeIt","wantedField"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ValidationContext\", {\n  enumerable: true,\n  get: function get() {\n    return _ValidationContext.default;\n  }\n});\nexports.SimpleSchema = exports.schemaDefinitionOptions = void 0;\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _messageBox = _interopRequireDefault(require(\"message-box\"));\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _humanize = _interopRequireDefault(require(\"./humanize\"));\n\nvar _ValidationContext = _interopRequireDefault(require(\"./ValidationContext\"));\n\nvar _SimpleSchemaGroup = _interopRequireDefault(require(\"./SimpleSchemaGroup\"));\n\nvar _regExp = _interopRequireDefault(require(\"./regExp\"));\n\nvar _clean2 = _interopRequireDefault(require(\"./clean\"));\n\nvar _expandShorthand = _interopRequireDefault(require(\"./expandShorthand\"));\n\nvar _utility = require(\"./utility\");\n\nvar _defaultMessages = _interopRequireDefault(require(\"./defaultMessages\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Exported for tests\nvar schemaDefinitionOptions = ['type', 'label', 'optional', 'required', 'autoValue', 'defaultValue'];\nexports.schemaDefinitionOptions = schemaDefinitionOptions;\nvar oneOfProps = ['type', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx', 'custom', 'blackbox', 'trim'];\nvar propsThatCanBeFunction = ['label', 'optional', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx'];\n\nvar SimpleSchema =\n/*#__PURE__*/\nfunction () {\n  function SimpleSchema() {\n    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        check = _ref.check,\n        cleanOptions = _ref.clean,\n        defaultLabel = _ref.defaultLabel,\n        _ref$humanizeAutoLabe = _ref.humanizeAutoLabels,\n        humanizeAutoLabels = _ref$humanizeAutoLabe === void 0 ? true : _ref$humanizeAutoLabe,\n        _ref$requiredByDefaul = _ref.requiredByDefault,\n        requiredByDefault = _ref$requiredByDefaul === void 0 ? true : _ref$requiredByDefaul,\n        tracker = _ref.tracker;\n\n    _classCallCheck(this, SimpleSchema);\n\n    _defineProperty(this, \"pick\", getPickOrOmit('pick'));\n\n    _defineProperty(this, \"omit\", getPickOrOmit('omit'));\n\n    // Stash the options object\n    this._constructorOptions = {\n      check: check,\n      defaultLabel: defaultLabel,\n      humanizeAutoLabels: humanizeAutoLabels,\n      requiredByDefault: requiredByDefault,\n      tracker: tracker\n    }; // Custom validators for this instance\n\n    this._validators = [];\n    this._docValidators = []; // Named validation contexts\n\n    this._validationContexts = {}; // Schema-level defaults for cleaning\n\n    this._cleanOptions = _objectSpread({\n      filter: true,\n      autoConvert: true,\n      removeEmptyStrings: true,\n      trimStrings: true,\n      getAutoValues: true,\n      removeNullsFromArrays: false,\n      extendAutoValueContext: {}\n    }, cleanOptions); // Clone, expanding shorthand, and store the schema object in this._schema\n\n    this._schema = {};\n    this._depsLabels = {};\n    this.extend(schema); // Define default validation error messages\n\n    this.messageBox = new _messageBox.default((0, _clone.default)(_defaultMessages.default));\n    this.version = SimpleSchema.version;\n  }\n\n  _createClass(SimpleSchema, [{\n    key: \"forEachAncestorSimpleSchema\",\n    value: function forEachAncestorSimpleSchema(key, func) {\n      var _this = this;\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key);\n\n      (0, _utility.forEachKeyAncestor)(genericKey, function (ancestor) {\n        var def = _this._schema[ancestor];\n        if (!def) return;\n        def.type.definitions.forEach(function (typeDef) {\n          if (SimpleSchema.isSimpleSchema(typeDef.type)) {\n            func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\n          }\n        });\n      });\n    }\n    /**\n     * Returns whether the obj is a SimpleSchema object.\n     * @param {Object} [obj] An object to test\n     * @returns {Boolean} True if the given object appears to be a SimpleSchema instance\n     */\n\n  }, {\n    key: \"reactiveLabelDependency\",\n\n    /**\n     * For Meteor apps, add a reactive dependency on the label\n     * for a key.\n     */\n    value: function reactiveLabelDependency(key) {\n      var tracker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._constructorOptions.tracker;\n      if (!key || !tracker) return;\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key); // If in this schema\n\n\n      if (this._schema[genericKey]) {\n        if (!this._depsLabels[genericKey]) {\n          this._depsLabels[genericKey] = new tracker.Dependency();\n        }\n\n        this._depsLabels[genericKey].depend();\n\n        return;\n      } // If in subschema\n\n\n      this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n        // Pass tracker down so that we get reactivity even if the subschema\n        // didn't have tracker option set\n        simpleSchema.reactiveLabelDependency(subSchemaKey, tracker);\n      });\n    }\n    /**\n     * @param {String} [key] One specific or generic key for which to get the schema.\n     * @returns {Object} The entire schema object or just the definition for one key.\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"schema\",\n    value: function schema(key) {\n      if (!key) return this._schema;\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key);\n\n      var keySchema = this._schema[genericKey]; // If not defined in this schema, see if it's defined in a subschema\n\n      if (!keySchema) {\n        var found = false;\n        this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n          if (!found) keySchema = simpleSchema.schema(subSchemaKey);\n          if (keySchema) found = true;\n        });\n      }\n\n      return keySchema;\n    }\n    /**\n     * @returns {Object} The entire schema object with subschemas merged. This is the\n     * equivalent of what schema() returned in SimpleSchema < 2.0\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"mergedSchema\",\n    value: function mergedSchema() {\n      var _this2 = this;\n\n      var mergedSchema = {};\n\n      this._schemaKeys.forEach(function (key) {\n        var keySchema = _this2._schema[key];\n        mergedSchema[key] = keySchema;\n        keySchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          var childSchema = typeDef.type.mergedSchema();\n          Object.keys(childSchema).forEach(function (subKey) {\n            mergedSchema[\"\".concat(key, \".\").concat(subKey)] = childSchema[subKey];\n          });\n        });\n      });\n\n      return mergedSchema;\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param {String} key Generic or specific schema key\n     * @param {Array(String)} [propList] Array of schema properties you need; performance optimization\n     * @param {Object} [functionContext] The context to use when evaluating schema options that are functions\n     * @returns {Object} The schema definition for the requested key\n     */\n\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(key, propList) {\n      var _this3 = this;\n\n      var functionContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var defs = this.schema(key);\n      if (!defs) return;\n\n      var getPropIterator = function getPropIterator(obj, newObj) {\n        return function (prop) {\n          if (Array.isArray(propList) && !propList.includes(prop)) return;\n          var val = obj[prop]; // For any options that support specifying a function, evaluate the functions\n\n          if (propsThatCanBeFunction.indexOf(prop) > -1 && typeof val === 'function') {\n            newObj[prop] = val.call(_objectSpread({\n              key: key\n            }, functionContext)); // Inflect label if undefined\n\n            if (prop === 'label' && typeof newObj[prop] !== 'string') newObj[prop] = inflectedLabel(key, _this3._constructorOptions.humanizeAutoLabels);\n          } else {\n            newObj[prop] = val;\n          }\n        };\n      };\n\n      var result = {};\n      Object.keys(defs).forEach(getPropIterator(defs, result)); // Resolve all the types and convert to a normal array to make it easier\n      // to use.\n\n      if (defs.type) {\n        result.type = defs.type.definitions.map(function (typeDef) {\n          var newTypeDef = {};\n          Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\n          return newTypeDef;\n        });\n      }\n\n      return result;\n    }\n    /**\n     * Returns a string identifying the best guess data type for a key. For keys\n     * that allow multiple types, the first type is used. This can be useful for\n     * building forms.\n     *\n     * @param {String} key Generic or specific schema key\n     * @returns {String} A type string. One of:\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\n     *  dateArray, objectArray\n     */\n\n  }, {\n    key: \"getQuickTypeForKey\",\n    value: function getQuickTypeForKey(key) {\n      var type;\n      var fieldSchema = this.schema(key);\n      if (!fieldSchema) return;\n      var fieldType = fieldSchema.type.singleType;\n\n      if (fieldType === String) {\n        type = 'string';\n      } else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\n        type = 'number';\n      } else if (fieldType === Boolean) {\n        type = 'boolean';\n      } else if (fieldType === Date) {\n        type = 'date';\n      } else if (fieldType === Array) {\n        var arrayItemFieldSchema = this.schema(\"\".concat(key, \".$\"));\n        if (!arrayItemFieldSchema) return;\n        var arrayItemFieldType = arrayItemFieldSchema.type.singleType;\n\n        if (arrayItemFieldType === String) {\n          type = 'stringArray';\n        } else if (arrayItemFieldType === Number || arrayItemFieldType === SimpleSchema.Integer) {\n          type = 'numberArray';\n        } else if (arrayItemFieldType === Boolean) {\n          type = 'booleanArray';\n        } else if (arrayItemFieldType === Date) {\n          type = 'dateArray';\n        } else if (arrayItemFieldType === Object || SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\n          type = 'objectArray';\n        }\n      } else if (fieldType === Object) {\n        type = 'object';\n      }\n\n      return type;\n    }\n    /**\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\n     *\n     * @param {String} key Generic or specific schema key\n     */\n\n  }, {\n    key: \"getObjectSchema\",\n    value: function getObjectSchema(key) {\n      var newSchemaDef = {};\n\n      var genericKey = _mongoObject.default.makeKeyGeneric(key);\n\n      var searchString = \"\".concat(genericKey, \".\");\n      var mergedSchema = this.mergedSchema();\n      Object.keys(mergedSchema).forEach(function (k) {\n        if (k.indexOf(searchString) === 0) {\n          newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\n        }\n      });\n      return this._copyWithSchema(newSchemaDef);\n    } // Returns an array of all the autovalue functions, including those in subschemas all the\n    // way down the schema tree\n\n  }, {\n    key: \"autoValueFunctions\",\n    value: function autoValueFunctions() {\n      var _this4 = this;\n\n      var result = [].concat(this._autoValues);\n\n      this._schemaKeys.forEach(function (key) {\n        _this4._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          result = result.concat(typeDef.type.autoValueFunctions().map(function (_ref2) {\n            var func = _ref2.func,\n                fieldName = _ref2.fieldName,\n                closestSubschemaFieldName = _ref2.closestSubschemaFieldName;\n            return {\n              func: func,\n              fieldName: \"\".concat(key, \".\").concat(fieldName),\n              closestSubschemaFieldName: closestSubschemaFieldName.length ? \"\".concat(key, \".\").concat(closestSubschemaFieldName) : key\n            };\n          }));\n        });\n      });\n\n      return result;\n    } // Returns an array of all the blackbox keys, including those in subschemas\n\n  }, {\n    key: \"blackboxKeys\",\n    value: function blackboxKeys() {\n      var _this5 = this;\n\n      var blackboxKeys = new Set(this._blackboxKeys);\n\n      this._schemaKeys.forEach(function (key) {\n        _this5._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          typeDef.type.blackboxKeys().forEach(function (blackboxKey) {\n            blackboxKeys.add(\"\".concat(key, \".\").concat(blackboxKey));\n          });\n        });\n      });\n\n      return Array.from(blackboxKeys);\n    } // Check if the key is a nested dot-syntax key inside of a blackbox object\n\n  }, {\n    key: \"keyIsInBlackBox\",\n    value: function keyIsInBlackBox(key) {\n      var _this6 = this;\n\n      var isInBlackBox = false;\n      (0, _utility.forEachKeyAncestor)(_mongoObject.default.makeKeyGeneric(key), function (ancestor, remainder) {\n        if (_this6._blackboxKeys.has(ancestor)) {\n          isInBlackBox = true;\n        } else {\n          var testKeySchema = _this6.schema(ancestor);\n\n          if (testKeySchema) {\n            testKeySchema.type.definitions.forEach(function (typeDef) {\n              if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n              if (typeDef.type.keyIsInBlackBox(remainder)) isInBlackBox = true;\n            });\n          }\n        }\n      });\n      return isInBlackBox;\n    } // Returns true if key is explicitly allowed by the schema or implied\n    // by other explicitly allowed keys.\n    // The key string should have $ in place of any numeric array positions.\n\n  }, {\n    key: \"allowsKey\",\n    value: function allowsKey(key) {\n      var _this7 = this;\n\n      // Loop through all keys in the schema\n      return this._schemaKeys.some(function (loopKey) {\n        // If the schema key is the test key, it's allowed.\n        if (loopKey === key) return true;\n\n        var fieldSchema = _this7.schema(loopKey);\n\n        var compare1 = key.slice(0, loopKey.length + 2);\n        var compare2 = compare1.slice(0, -1); // Blackbox and subschema checks are needed only if key starts with\n        // loopKey + a dot\n\n        if (compare2 !== \"\".concat(loopKey, \".\")) return false; // Black box handling\n\n        if (_this7._blackboxKeys.has(loopKey)) {\n          // If the test key is the black box key + \".$\", then the test\n          // key is NOT allowed because black box keys are by definition\n          // only for objects, and not for arrays.\n          return compare1 !== \"\".concat(loopKey, \".$\");\n        } // Subschemas\n\n\n        var allowed = false;\n        var subKey = key.slice(loopKey.length + 1);\n        fieldSchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          if (typeDef.type.allowsKey(subKey)) allowed = true;\n        });\n        return allowed;\n      });\n    }\n    /**\n     * Returns all the child keys for the object identified by the generic prefix,\n     * or all the top level keys if no prefix is supplied.\n     *\n     * @param {String} [keyPrefix] The Object-type generic key for which to get child keys. Omit for\n     *   top-level Object-type keys\n     * @returns {[[Type]]} [[Description]]\n     */\n\n  }, {\n    key: \"objectKeys\",\n    value: function objectKeys(keyPrefix) {\n      if (!keyPrefix) return this._firstLevelSchemaKeys;\n      return this._objectKeys[\"\".concat(keyPrefix, \".\")] || [];\n    }\n    /**\n     * Copies this schema into a new instance with the same validators, messages,\n     * and options, but with different keys as defined in `schema` argument\n     *\n     * @param {Object} schema\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"_copyWithSchema\",\n    value: function _copyWithSchema(schema) {\n      var cl = new SimpleSchema(schema, _objectSpread({}, this._constructorOptions));\n      cl._cleanOptions = this._cleanOptions;\n      cl.messageBox = this.messageBox.clone();\n      return cl;\n    }\n    /**\n     * Clones this schema into a new instance with the same schema keys, validators,\n     * and options.\n     *\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this._copyWithSchema(this._schema);\n    }\n    /**\n     * Extends (mutates) this schema with another schema, key by key.\n     *\n     * @param {SimpleSchema|Object} schema\n     * @returns The SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var _this8 = this;\n\n      var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (Array.isArray(schema)) throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\n      var schemaObj;\n\n      if (SimpleSchema.isSimpleSchema(schema)) {\n        schemaObj = schema._schema;\n        this._validators = this._validators.concat(schema._validators);\n        this._docValidators = this._docValidators.concat(schema._docValidators);\n        Object.assign(this._cleanOptions, schema._cleanOptions);\n        Object.assign(this._constructorOptions, schema._constructorOptions);\n      } else {\n        schemaObj = (0, _expandShorthand.default)(schema);\n      } // Update all of the information cached on the instance\n\n\n      Object.keys(schemaObj).forEach(function (fieldName) {\n        var definition = standardizeDefinition(schemaObj[fieldName]); // Merge/extend with any existing definition\n\n        if (_this8._schema[fieldName]) {\n          if (!Object.prototype.hasOwnProperty.call(_this8._schema, fieldName)) {\n            // fieldName is actually a method from Object itself!\n            throw new Error(\"\".concat(fieldName, \" key is actually the name of a method on Object, please rename it\"));\n          }\n\n          var type = definition.type,\n              definitionWithoutType = _objectWithoutProperties(definition, [\"type\"]); // eslint-disable-line no-unused-vars\n\n\n          _this8._schema[fieldName] = _objectSpread({}, _this8._schema[fieldName], {}, definitionWithoutType);\n          if (definition.type) _this8._schema[fieldName].type.extend(definition.type);\n        } else {\n          _this8._schema[fieldName] = definition;\n        }\n\n        checkAndScrubDefinition(fieldName, _this8._schema[fieldName], _this8._constructorOptions, schemaObj);\n      });\n      checkSchemaOverlap(this._schema); // Set/Reset all of these\n\n      this._schemaKeys = Object.keys(this._schema);\n      this._autoValues = [];\n      this._blackboxKeys = new Set();\n      this._firstLevelSchemaKeys = [];\n      this._objectKeys = {}; // Update all of the information cached on the instance\n\n      this._schemaKeys.forEach(function (fieldName) {\n        // Make sure parent has a definition in the schema. No implied objects!\n        if (fieldName.indexOf('.') > -1) {\n          var parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\n          if (!Object.prototype.hasOwnProperty.call(_this8._schema, parentFieldName)) throw new Error(\"\\\"\".concat(fieldName, \"\\\" is in the schema but \\\"\").concat(parentFieldName, \"\\\" is not\"));\n        }\n\n        var definition = _this8._schema[fieldName]; // Keep list of all top level keys\n\n        if (fieldName.indexOf('.') === -1) _this8._firstLevelSchemaKeys.push(fieldName); // Keep list of all blackbox keys for passing to MongoObject constructor\n        // XXX For now if any oneOf type is blackbox, then the whole field is.\n\n        /* eslint-disable no-restricted-syntax */\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = definition.type.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var oneOfDef = _step.value;\n\n            // XXX If the type is SS.Any, also consider it a blackbox\n            if (oneOfDef.blackbox === true || oneOfDef.type === SimpleSchema.Any) {\n              _this8._blackboxKeys.add(fieldName);\n\n              break;\n            }\n          }\n          /* eslint-enable no-restricted-syntax */\n          // Keep list of autoValue functions\n\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (typeof definition.autoValue === 'function') {\n          _this8._autoValues.push({\n            closestSubschemaFieldName: '',\n            fieldName: fieldName,\n            func: definition.autoValue\n          });\n        }\n      }); // Store child keys keyed by parent. This needs to be done recursively to handle\n      // subschemas.\n\n\n      var setObjectKeys = function setObjectKeys(curSchema, schemaParentKey) {\n        Object.keys(curSchema).forEach(function (fieldName) {\n          var definition = curSchema[fieldName];\n          fieldName = schemaParentKey ? \"\".concat(schemaParentKey, \".\").concat(fieldName) : fieldName;\n\n          if (fieldName.indexOf('.') > -1 && fieldName.slice(-2) !== '.$') {\n            var parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\n            var parentKeyWithDot = \"\".concat(parentKey, \".\");\n            _this8._objectKeys[parentKeyWithDot] = _this8._objectKeys[parentKeyWithDot] || [];\n\n            _this8._objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\n          } // If the current field is a nested SimpleSchema,\n          // iterate over the child fields and cache their properties as well\n\n\n          definition.type.definitions.forEach(function (_ref3) {\n            var type = _ref3.type;\n\n            if (SimpleSchema.isSimpleSchema(type)) {\n              setObjectKeys(type._schema, fieldName);\n            }\n          });\n        });\n      };\n\n      setObjectKeys(this._schema);\n      return this;\n    }\n  }, {\n    key: \"getAllowedValuesForKey\",\n    value: function getAllowedValuesForKey(key) {\n      // For array fields, `allowedValues` is on the array item definition\n      if (this.allowsKey(\"\".concat(key, \".$\"))) {\n        key = \"\".concat(key, \".$\");\n      }\n\n      var allowedValues = this.get(key, 'allowedValues');\n\n      if (Array.isArray(allowedValues) || allowedValues instanceof Set) {\n        return _toConsumableArray(allowedValues);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"newContext\",\n    value: function newContext() {\n      return new _ValidationContext.default(this);\n    }\n  }, {\n    key: \"namedContext\",\n    value: function namedContext(name) {\n      if (typeof name !== 'string') name = 'default';\n\n      if (!this._validationContexts[name]) {\n        this._validationContexts[name] = new _ValidationContext.default(this);\n      }\n\n      return this._validationContexts[name];\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      this._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      this._docValidators.push(func);\n    }\n    /**\n     * @param obj {Object|Object[]} Object or array of objects to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(obj) {\n      var _this9 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // For Meteor apps, `check` option can be passed to silence audit-argument-checks\n      var check = options.check || this._constructorOptions.check;\n\n      if (typeof check === 'function') {\n        // Call check but ignore the error\n        try {\n          check(obj);\n        } catch (e) {\n          /* ignore error */\n        }\n      } // obj can be an array, in which case we validate each object in it and\n      // throw as soon as one has an error\n\n\n      var objects = Array.isArray(obj) ? obj : [obj];\n      objects.forEach(function (oneObj) {\n        var validationContext = _this9.newContext();\n\n        var isValid = validationContext.validate(oneObj, options);\n        if (isValid) return;\n        var errors = validationContext.validationErrors(); // In order for the message at the top of the stack trace to be useful,\n        // we set it to the first validation error message.\n\n        var message = _this9.messageForError(errors[0]);\n\n        var error = new Error(message);\n        error.errorType = 'ClientError';\n        error.name = 'ClientError';\n        error.error = 'validation-error'; // Add meaningful error messages for each validation error.\n        // Useful for display messages when using 'mdg:validated-method'.\n\n        error.details = errors.map(function (errorDetail) {\n          return _objectSpread({}, errorDetail, {\n            message: _this9.messageForError(errorDetail)\n          });\n        }); // The primary use for the validationErrorTransform is to convert the\n        // vanilla Error into a Meteor.Error until DDP is able to pass\n        // vanilla errors back to the client.\n\n        if (typeof SimpleSchema.validationErrorTransform === 'function') {\n          throw SimpleSchema.validationErrorTransform(error);\n        } else {\n          throw error;\n        }\n      });\n    }\n    /**\n     * @param obj {Object} Object to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Returns a Promise that resolves with the errors\n     */\n\n  }, {\n    key: \"validateAndReturnErrorsPromise\",\n    value: function validateAndReturnErrorsPromise(obj, options) {\n      var _this10 = this;\n\n      var validationContext = this.newContext();\n      var isValid = validationContext.validate(obj, options);\n      if (isValid) return Promise.resolve([]); // Add the `message` prop\n\n      var errors = validationContext.validationErrors().map(function (errorDetail) {\n        return _objectSpread({}, errorDetail, {\n          message: _this10.messageForError(errorDetail)\n        });\n      });\n      return Promise.resolve(errors);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var _this11 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function (obj) {\n        var optionsClone = _objectSpread({}, options);\n\n        if (options.clean === true) {\n          // Do this here and pass into both functions for better performance\n          optionsClone.mongoObject = new _mongoObject.default(obj, _this11.blackboxKeys());\n\n          _this11.clean(obj, optionsClone);\n        }\n\n        if (options.returnErrorsPromise) {\n          return _this11.validateAndReturnErrorsPromise(obj, optionsClone);\n        }\n\n        return _this11.validate(obj, optionsClone);\n      };\n    }\n  }, {\n    key: \"getFormValidator\",\n    value: function getFormValidator() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.validator(_objectSpread({}, options, {\n        returnErrorsPromise: true\n      }));\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _clean2.default.apply(void 0, [this].concat(args));\n    }\n    /**\n     * Change schema labels on the fly, causing mySchema.label computation\n     * to rerun. Useful when the user changes the language.\n     *\n     * @param {Object} labels A dictionary of all the new label values, by schema key.\n     */\n\n  }, {\n    key: \"labels\",\n    value: function labels(_labels) {\n      var _this12 = this;\n\n      Object.keys(_labels).forEach(function (key) {\n        var label = _labels[key];\n        if (typeof label !== 'string' && typeof label !== 'function') return;\n        if (!Object.prototype.hasOwnProperty.call(_this12._schema, key)) return;\n        _this12._schema[key].label = label;\n        _this12._depsLabels[key] && _this12._depsLabels[key].changed();\n      });\n    }\n    /**\n     * Gets a field's label or all field labels reactively.\n     *\n     * @param {String} [key] The schema key, specific or generic.\n     *   Omit this argument to get a dictionary of all labels.\n     * @returns {String} The label\n     */\n\n  }, {\n    key: \"label\",\n    value: function label(key) {\n      var _this13 = this;\n\n      // Get all labels\n      if (key === null || key === undefined) {\n        var result = {};\n\n        this._schemaKeys.forEach(function (schemaKey) {\n          result[schemaKey] = _this13.label(schemaKey);\n        });\n\n        return result;\n      } // Get label for one field\n\n\n      var label = this.get(key, 'label');\n      if (label) this.reactiveLabelDependency(key);\n      return label || null;\n    }\n    /**\n     * Gets a field's property\n     *\n     * @param {String} key The schema key, specific or generic.\n     * @param {String} prop Name of the property to get for that schema key\n     * @param {Object} [functionContext] The `this` context to use if prop is a function\n     * @returns {any} The property value\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, prop, functionContext) {\n      var def = this.getDefinition(key, ['type', prop], functionContext);\n      if (!def) return undefined;\n\n      if (schemaDefinitionOptions.includes(prop)) {\n        return def[prop];\n      }\n\n      return (def.type.find(function (props) {\n        return props[prop];\n      }) || {})[prop];\n    } // shorthand for getting defaultValue\n\n  }, {\n    key: \"defaultValue\",\n    value: function defaultValue(key) {\n      return this.get(key, 'defaultValue');\n    } // Returns a string message for the given error type and key. Passes through\n    // to message-box pkg.\n\n  }, {\n    key: \"messageForError\",\n    value: function messageForError(errorInfo) {\n      var name = errorInfo.name;\n      return this.messageBox.message(errorInfo, {\n        context: {\n          key: name,\n          // backward compatibility\n          // The call to this.label() establishes a reactive dependency, too\n          label: this.label(name)\n        }\n      });\n    }\n    /**\n     * @method SimpleSchema#pick\n     * @param {[fields]} The list of fields to pick to instantiate the subschema\n     * @returns {SimpleSchema} The subschema\n     */\n\n  }], [{\n    key: \"isSimpleSchema\",\n    value: function isSimpleSchema(obj) {\n      return obj && (obj instanceof SimpleSchema || obj._schema);\n    }\n  }, {\n    key: \"extendOptions\",\n    // If you need to allow properties other than those listed above, call this from your app or package\n    value: function extendOptions(options) {\n      // For backwards compatibility we still take an object here, but we only care about the names\n      if (!Array.isArray(options)) options = Object.keys(options);\n      options.forEach(function (option) {\n        schemaDefinitionOptions.push(option);\n      });\n    }\n  }, {\n    key: \"defineValidationErrorTransform\",\n    value: function defineValidationErrorTransform(transform) {\n      if (typeof transform !== 'function') {\n        throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\n      }\n\n      SimpleSchema.validationErrorTransform = transform;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(obj, schema, options) {\n      // Allow passing just the schema object\n      if (!SimpleSchema.isSimpleSchema(schema)) {\n        schema = new SimpleSchema(schema);\n      }\n\n      return schema.validate(obj, options);\n    }\n  }, {\n    key: \"oneOf\",\n    value: function oneOf() {\n      for (var _len2 = arguments.length, definitions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        definitions[_key2] = arguments[_key2];\n      }\n\n      return _construct(_SimpleSchemaGroup.default, definitions);\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      SimpleSchema._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      SimpleSchema._docValidators.push(func);\n    }\n  }]);\n\n  return SimpleSchema;\n}();\n/*\n * PRIVATE\n */\n// Throws an error if any fields are `type` SimpleSchema but then also\n// have subfields defined outside of that.\n\n\nexports.SimpleSchema = SimpleSchema;\n\n_defineProperty(SimpleSchema, \"version\", 2);\n\n_defineProperty(SimpleSchema, \"Any\", '___Any___');\n\n_defineProperty(SimpleSchema, \"RegEx\", _regExp.default);\n\n_defineProperty(SimpleSchema, \"_validators\", []);\n\n_defineProperty(SimpleSchema, \"_docValidators\", []);\n\n_defineProperty(SimpleSchema, \"ErrorTypes\", {\n  REQUIRED: 'required',\n  MIN_STRING: 'minString',\n  MAX_STRING: 'maxString',\n  MIN_NUMBER: 'minNumber',\n  MAX_NUMBER: 'maxNumber',\n  MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\n  MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\n  MIN_DATE: 'minDate',\n  MAX_DATE: 'maxDate',\n  BAD_DATE: 'badDate',\n  MIN_COUNT: 'minCount',\n  MAX_COUNT: 'maxCount',\n  MUST_BE_INTEGER: 'noDecimal',\n  VALUE_NOT_ALLOWED: 'notAllowed',\n  EXPECTED_TYPE: 'expectedType',\n  FAILED_REGULAR_EXPRESSION: 'regEx',\n  KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\n});\n\n_defineProperty(SimpleSchema, \"Integer\", 'SimpleSchema.Integer');\n\n_defineProperty(SimpleSchema, \"_makeGeneric\", _mongoObject.default.makeKeyGeneric);\n\n_defineProperty(SimpleSchema, \"ValidationContext\", _ValidationContext.default);\n\n_defineProperty(SimpleSchema, \"setDefaultMessages\", function (messages) {\n  (0, _utility.merge)(_defaultMessages.default, messages);\n});\n\nfunction checkSchemaOverlap(schema) {\n  Object.keys(schema).forEach(function (key) {\n    var val = schema[key];\n    if (!val.type) throw new Error(\"\".concat(key, \" key is missing \\\"type\\\"\"));\n    val.type.definitions.forEach(function (def) {\n      if (!SimpleSchema.isSimpleSchema(def.type)) return;\n      Object.keys(def.type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(key, \".\").concat(subKey);\n\n        if (Object.prototype.hasOwnProperty.call(schema, newKey)) {\n          throw new Error(\"The type for \\\"\".concat(key, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(key, \".\").concat(subKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(key, \".\").concat(subKey, \"\\\"\"));\n        }\n      });\n    });\n  });\n}\n/**\n * @param {String} fieldName The full generic schema key\n * @param {Boolean} shouldHumanize Humanize it\n * @returns {String} A label based on the key\n */\n\n\nfunction inflectedLabel(fieldName, shouldHumanize) {\n  var pieces = fieldName.split('.');\n  var label;\n\n  do {\n    label = pieces.pop();\n  } while (label === '$' && pieces.length);\n\n  return shouldHumanize ? (0, _humanize.default)(label) : label;\n}\n\nfunction getDefaultAutoValueFunction(defaultValue) {\n  return function defaultAutoValueFunction() {\n    if (this.isSet) return;\n    if (this.operator === null) return defaultValue; // Handle the case when pulling an object from an array the object contains a field\n    // which has a defaultValue. We don't want the default value to be returned in this case\n\n    if (this.operator === '$pull') return; // Handle the case where we are $pushing an object into an array of objects and we\n    // want any fields missing from that object to be added if they have default values\n\n    if (this.operator === '$push') return defaultValue; // If parent is set, we should update this position instead of $setOnInsert\n\n    if (this.parentField().isSet) return defaultValue; // Make sure the default value is added on upsert insert\n\n    if (this.isUpsert) return {\n      $setOnInsert: defaultValue\n    };\n  };\n} // Mutates def into standardized object with SimpleSchemaGroup type\n\n\nfunction standardizeDefinition(def) {\n  var standardizedDef = Object.keys(def).reduce(function (newDef, prop) {\n    if (!oneOfProps.includes(prop)) {\n      newDef[prop] = def[prop];\n    }\n\n    return newDef;\n  }, {}); // Internally, all definition types are stored as groups for simplicity of access.\n  // If we are extending, there may not actually be def.type, but it's okay because\n  // it will be added later when the two SimpleSchemaGroups are merged.\n\n  if (def.type && def.type instanceof _SimpleSchemaGroup.default) {\n    standardizedDef.type = def.type.clone();\n  } else {\n    var groupProps = Object.keys(def).reduce(function (newDef, prop) {\n      if (oneOfProps.includes(prop)) {\n        newDef[prop] = def[prop];\n      }\n\n      return newDef;\n    }, {});\n    standardizedDef.type = new _SimpleSchemaGroup.default(groupProps);\n  }\n\n  return standardizedDef;\n} // Checks and mutates definition. Clone it first.\n\n\nfunction checkAndScrubDefinition(fieldName, definition, options, fullSchemaObj) {\n  if (!definition.type) throw new Error(\"\".concat(fieldName, \" key is missing \\\"type\\\"\")); // Validate the field definition\n\n  Object.keys(definition).forEach(function (key) {\n    if (schemaDefinitionOptions.indexOf(key) === -1) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"\").concat(key, \"\\\" is not a supported property\"));\n    }\n  }); // Make sure the `type`s are OK\n\n  var couldBeArray = false;\n  definition.type.definitions.forEach(function (_ref4) {\n    var type = _ref4.type;\n    if (!type) throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" option is required\"));\n\n    if (Array.isArray(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an array. Change it to Array.\"));\n    }\n\n    if (type.constructor === Object && (0, _utility.isEmptyObject)(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an object. Change it to Object\"));\n    }\n\n    if (type === Array) couldBeArray = true;\n\n    if (SimpleSchema.isSimpleSchema(type)) {\n      Object.keys(type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(fieldName, \".\").concat(subKey);\n\n        if (Object.prototype.hasOwnProperty.call(fullSchemaObj, newKey)) {\n          throw new Error(\"The type for \\\"\".concat(fieldName, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(newKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(newKey, \"\\\"\"));\n        }\n      });\n    }\n  }); // If at least one of the possible types is Array, then make sure we have a\n  // definition for the array items, too.\n\n  if (couldBeArray && !Object.prototype.hasOwnProperty.call(fullSchemaObj, \"\".concat(fieldName, \".$\"))) {\n    throw new Error(\"\\\"\".concat(fieldName, \"\\\" is Array type but the schema does not include a \\\"\").concat(fieldName, \".$\\\" definition for the array items\\\"\"));\n  } // defaultValue -> autoValue\n  // We support defaultValue shortcut by converting it immediately into an\n  // autoValue.\n\n\n  if ('defaultValue' in definition) {\n    if ('autoValue' in definition && !definition.autoValue.isDefault) {\n      console.warn(\"SimpleSchema: Found both autoValue and defaultValue options for \\\"\".concat(fieldName, \"\\\". Ignoring defaultValue.\"));\n    } else {\n      if (fieldName.endsWith('.$')) {\n        throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n      }\n\n      definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\n      definition.autoValue.isDefault = true;\n    }\n  } // REQUIREDNESS\n\n\n  if (fieldName.endsWith('.$')) {\n    definition.optional = true;\n  } else if (!Object.prototype.hasOwnProperty.call(definition, 'optional')) {\n    if (Object.prototype.hasOwnProperty.call(definition, 'required')) {\n      if (typeof definition.required === 'function') {\n        definition.optional = function optional() {\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          return !definition.required.apply(this, args);\n        };\n      } else {\n        definition.optional = !definition.required;\n      }\n    } else {\n      definition.optional = options.requiredByDefault === false;\n    }\n  }\n\n  delete definition.required; // LABELS\n\n  if (!Object.prototype.hasOwnProperty.call(definition, 'label')) {\n    if (options.defaultLabel) {\n      definition.label = options.defaultLabel;\n    } else if (SimpleSchema.defaultLabel) {\n      definition.label = SimpleSchema.defaultLabel;\n    } else {\n      definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\n    }\n  }\n}\n\nfunction getPickOrOmit(type) {\n  return function pickOrOmit() {\n    var _this14 = this;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    // If they are picking/omitting an object or array field, we need to also include everything under it\n    var newSchema = {};\n\n    this._schemaKeys.forEach(function (key) {\n      // Pick/omit it if it IS in the array of keys they want OR if it\n      // STARTS WITH something that is in the array plus a period\n      var includeIt = args.some(function (wantedField) {\n        return key === wantedField || key.indexOf(\"\".concat(wantedField, \".\")) === 0;\n      });\n\n      if (includeIt && type === 'pick' || !includeIt && type === 'omit') {\n        newSchema[key] = _this14._schema[key];\n      }\n    });\n\n    return this._copyWithSchema(newSchema);\n  };\n}"]},"metadata":{},"sourceType":"script"}